"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@meilisearch";
exports.ids = ["vendor-chunks/@meilisearch"];
exports.modules = {

/***/ "(ssr)/./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.esm.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   instantMeiliSearch: () => (/* binding */ instantMeiliSearch)\n/* harmony export */ });\n/* harmony import */ var meilisearch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! meilisearch */ \"(ssr)/./node_modules/meilisearch/dist/bundles/meilisearch.cjs.js\");\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\n\nvar removeUndefined = function (arr) {\r\n    return arr.filter(function (x) { return x !== undefined; });\r\n};\n\n/**\r\n * @param  {any} str\r\n * @returns {boolean}\r\n */\r\n/**\r\n * @param  {string} filter\r\n * @returns {string}\r\n */\r\nfunction replaceColonByEqualSign(filter) {\r\n    // will only change first occurence of `:`\r\n    return filter.replace(/:(.*)/i, '=\"$1\"');\r\n}\r\n/**\r\n * @param  {any[]} arr\r\n * @returns {string}\r\n */\r\nfunction stringifyArray(arr) {\r\n    return arr.reduce(function (acc, curr) {\r\n        return (acc += JSON.stringify(curr));\r\n    }, '');\r\n}\n\n/**\r\n * @param  {number} dividend\r\n * @param  {number} divisor\r\n * @returns number\r\n */\r\nfunction ceiledDivision(dividend, divisor) {\r\n    if (divisor > 0) {\r\n        var NumberPages = Math.ceil(dividend / divisor); // total number of pages rounded up to the next largest integer.\r\n        return NumberPages;\r\n    }\r\n    return 0;\r\n}\n\nfunction isPureObject(data) {\r\n    return typeof data === 'object' && !Array.isArray(data) && data !== null;\r\n}\n\n/**\r\n * @param  {string} filter\r\n */\r\nvar adaptFilterSyntax = function (filter) {\r\n    var matches = filter.match(/([^=]*)=\"?([^\\\\\"]*)\"?$/);\r\n    if (matches) {\r\n        matches[0]; var filterName = matches[1], value = matches[2];\r\n        return [{ filterName: filterName, value: value }];\r\n    }\r\n    return [];\r\n};\r\n/**\r\n * @param  {Filter} filters?\r\n * @returns {Array}\r\n */\r\nfunction extractFilters(filters) {\r\n    if (typeof filters === 'string') {\r\n        return adaptFilterSyntax(filters);\r\n    }\r\n    else if (Array.isArray(filters)) {\r\n        return filters\r\n            .map(function (nestedFilter) {\r\n            if (Array.isArray(nestedFilter)) {\r\n                return nestedFilter.map(function (filter) { return adaptFilterSyntax(filter); });\r\n            }\r\n            return adaptFilterSyntax(nestedFilter);\r\n        })\r\n            .flat(2);\r\n    }\r\n    return [];\r\n}\r\n/**\r\n * @param  {Filter} filters?\r\n * @returns {FacetsCache}\r\n */\r\nfunction getFacetsFromFilter(filters) {\r\n    var extractedFilters = extractFilters(filters);\r\n    var cleanFilters = removeUndefined(extractedFilters);\r\n    return cleanFilters.reduce(function (cache, parsedFilter) {\r\n        var _a;\r\n        var filterName = parsedFilter.filterName, value = parsedFilter.value;\r\n        var prevFields = cache[filterName] || [];\r\n        cache = __assign(__assign({}, cache), (_a = {}, _a[filterName] = __spreadArray(__spreadArray([], prevFields, true), [value]), _a));\r\n        return cache;\r\n    }, {});\r\n}\r\nfunction getFacetsFromDefaultDistribution(facetsDistribution) {\r\n    return Object.keys(facetsDistribution).reduce(function (cache, facet) {\r\n        var _a;\r\n        var facetValues = Object.keys(facetsDistribution[facet]);\r\n        return __assign(__assign({}, cache), (_a = {}, _a[facet] = facetValues, _a));\r\n    }, {});\r\n}\r\n/**\r\n * @param  {Filter} filters?\r\n * @returns {FacetsCache}\r\n */\r\nfunction extractFacets(searchContext, searchParams) {\r\n    if (searchContext.keepZeroFacets) {\r\n        return getFacetsFromDefaultDistribution(searchContext.defaultFacetDistribution);\r\n    }\r\n    else {\r\n        return getFacetsFromFilter(searchParams === null || searchParams === void 0 ? void 0 : searchParams.filter);\r\n    }\r\n}\r\n/**\r\n * Assign missing filters to facetsDistribution.\r\n * All facet passed as filter should appear in the facetsDistribution.\r\n * If not present, the facet is added with 0 as value.\r\n *\r\n *\r\n * @param  {FacetsCache} cache?\r\n * @param  {FacetsDistribution} distribution?\r\n * @returns {FacetsDistribution}\r\n */\r\nfunction addMissingFacets(cachedFacets, distribution) {\r\n    distribution = distribution || {};\r\n    // If cachedFacets contains something\r\n    if (cachedFacets && Object.keys(cachedFacets).length > 0) {\r\n        // for all filters in cached filters\r\n        for (var cachedFacet in cachedFacets) {\r\n            // if facet does not exist on returned distribution, add an empty object\r\n            if (!distribution[cachedFacet])\r\n                distribution[cachedFacet] = {};\r\n            // for all fields in every filter\r\n            for (var _i = 0, _a = cachedFacets[cachedFacet]; _i < _a.length; _i++) {\r\n                var cachedField = _a[_i];\r\n                // if the field is not present in the returned distribution\r\n                // set it at 0\r\n                if (!Object.keys(distribution[cachedFacet]).includes(cachedField)) {\r\n                    // add 0 value\r\n                    distribution[cachedFacet][cachedField] = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return distribution;\r\n}\n\nvar emptySearch = {\r\n    hits: [],\r\n    query: '',\r\n    facetsDistribution: {},\r\n    limit: 0,\r\n    offset: 0,\r\n    exhaustiveNbHits: false,\r\n    nbHits: 0,\r\n    processingTimeMs: 0\r\n};\r\n/**\r\n * @param  {ResponseCacher} cache\r\n */\r\nfunction SearchResolver(cache) {\r\n    return {\r\n        /**\r\n         * @param  {SearchContext} searchContext\r\n         * @param  {MeiliSearchParams} searchParams\r\n         * @param  {MeiliSearch} client\r\n         * @returns {Promise}\r\n         */\r\n        searchResponse: function (searchContext, searchParams, client) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var placeholderSearch, query, pagination, paginationCache, key, cachedResponse, facetsCache, searchResponse;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            placeholderSearch = searchContext.placeholderSearch, query = searchContext.query;\r\n                            // query can be: empty string, undefined or null\r\n                            // all of them are falsy's\r\n                            if (!placeholderSearch && !query) {\r\n                                return [2 /*return*/, emptySearch];\r\n                            }\r\n                            pagination = searchContext.pagination;\r\n                            paginationCache = searchContext.finitePagination ? {} : pagination;\r\n                            key = cache.formatKey([\r\n                                searchParams,\r\n                                searchContext.indexUid,\r\n                                searchContext.query,\r\n                                paginationCache,\r\n                            ]);\r\n                            cachedResponse = cache.getEntry(key);\r\n                            // Check if specific request is already cached with its associated search response.\r\n                            if (cachedResponse)\r\n                                return [2 /*return*/, cachedResponse];\r\n                            facetsCache = extractFacets(searchContext, searchParams);\r\n                            return [4 /*yield*/, client\r\n                                    .index(searchContext.indexUid)\r\n                                    .search(searchContext.query, searchParams)\r\n                                // Add missing facets back into facetsDistribution\r\n                            ];\r\n                        case 1:\r\n                            searchResponse = _a.sent();\r\n                            // Add missing facets back into facetsDistribution\r\n                            searchResponse.facetsDistribution = addMissingFacets(facetsCache, searchResponse.facetsDistribution);\r\n                            // Cache response\r\n                            cache.setEntry(key, searchResponse);\r\n                            return [2 /*return*/, searchResponse];\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    };\r\n}\n\n/**\r\n * @param  {number} rad\r\n * @returns {number}\r\n */\r\nfunction rad2degr(rad) {\r\n    return (rad * 180) / Math.PI;\r\n}\r\n/**\r\n * @param  {number} degr\r\n * @returns {number}\r\n */\r\nfunction degr2rad(degr) {\r\n    return (degr * Math.PI) / 180;\r\n}\r\n/**\r\n * @param  {number} lat1\r\n * @param  {number} lng1\r\n * @param  {number} lat2\r\n * @param  {number} lng2\r\n * @returns {string}\r\n */\r\nfunction middleGeoPoints(lat1, lng1, lat2, lng2) {\r\n    // convert to radians\r\n    lat1 = degr2rad(lat1);\r\n    lng1 = degr2rad(lng1);\r\n    var x1 = Math.cos(lat1) * Math.cos(lng1);\r\n    var y1 = Math.cos(lat1) * Math.sin(lng1);\r\n    var z1 = Math.sin(lat1);\r\n    // convert to radians\r\n    lat2 = degr2rad(lat2);\r\n    lng2 = degr2rad(lng2);\r\n    var x2 = Math.cos(lat2) * Math.cos(lng2);\r\n    var y2 = Math.cos(lat2) * Math.sin(lng2);\r\n    var z2 = Math.sin(lat2);\r\n    var x = x1 + x2;\r\n    var y = y1 + y2;\r\n    var z = z1 + z2;\r\n    var Hyp = Math.sqrt(x * x + y * y);\r\n    var lng3 = Math.atan2(y, x);\r\n    var lat3 = Math.atan2(z, Hyp);\r\n    if (lng1 < lng2 || (lng1 > lng2 && lng1 > Math.PI && lng2 < -Math.PI)) {\r\n        lat3 = lat3 + Math.PI;\r\n        lng3 = lng3 + Math.PI;\r\n    }\r\n    else {\r\n        lat3 = rad2degr(lat3);\r\n        lng3 = rad2degr(lng3);\r\n    }\r\n    if (Math.abs(x) < Math.pow(10, -9) &&\r\n        Math.abs(y) < Math.pow(10, -9) &&\r\n        Math.abs(z) < Math.pow(10, -9)) {\r\n        lat3 = 0;\r\n        lng3 = 0;\r\n    }\r\n    return \"\".concat(lat3, \",\").concat(lng3);\r\n}\r\n/**\r\n * @param  {number} lat1\r\n * @param  {number} lng1\r\n * @param  {number} lat2\r\n * @param  {number} lng2\r\n * @returns {number}\r\n */\r\nfunction getDistanceInMeter(lat1, lng1, lat2, lng2) {\r\n    // Haversine Algorithm\r\n    var R = 6371e3; // metres\r\n    var latRad1 = (lat1 * Math.PI) / 180;\r\n    var latRad2 = (lat2 * Math.PI) / 180;\r\n    var latCenterRad = ((lat2 - lat1) * Math.PI) / 180;\r\n    var lngCenterRad = ((lng2 - lng1) * Math.PI) / 180;\r\n    var a = Math.sin(latCenterRad / 2) * Math.sin(latCenterRad / 2) +\r\n        Math.cos(latRad1) *\r\n            Math.cos(latRad2) *\r\n            Math.sin(lngCenterRad / 2) *\r\n            Math.sin(lngCenterRad / 2);\r\n    var bearing = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    var distance = R * bearing; // in metres\r\n    return distance;\r\n}\n\nfunction adaptGeoPointsRules(geoSearchContext) {\r\n    if (!geoSearchContext) {\r\n        return undefined;\r\n    }\r\n    var insideBoundingBox = geoSearchContext.insideBoundingBox, aroundLatLng = geoSearchContext.aroundLatLng, aroundRadius = geoSearchContext.aroundRadius, minimumAroundRadius = geoSearchContext.minimumAroundRadius;\r\n    var middlePoint;\r\n    var radius;\r\n    if (aroundLatLng) {\r\n        middlePoint = aroundLatLng;\r\n    }\r\n    if (aroundRadius != null || minimumAroundRadius != null) {\r\n        if (aroundRadius != null)\r\n            radius = aroundRadius;\r\n        else\r\n            radius = minimumAroundRadius;\r\n    }\r\n    // If insideBoundingBox is provided it takes precedent over all other options\r\n    if (insideBoundingBox && typeof insideBoundingBox === 'string') {\r\n        var _a = insideBoundingBox.split(','), lat1Raw = _a[0], lng1Raw = _a[1], lat2Raw = _a[2], lng2Raw = _a[3];\r\n        var _b = [\r\n            parseFloat(lat1Raw),\r\n            parseFloat(lng1Raw),\r\n            parseFloat(lat2Raw),\r\n            parseFloat(lng2Raw),\r\n        ], lat1 = _b[0], lng1 = _b[1], lat2 = _b[2], lng2 = _b[3];\r\n        radius = getDistanceInMeter(lat1, lng1, lat2, lng2) / 2;\r\n        middlePoint = middleGeoPoints(lat1, lng1, lat2, lng2);\r\n    }\r\n    if (middlePoint != null && radius != null) {\r\n        var _c = middlePoint.split(','), lat3 = _c[0], lng3 = _c[1];\r\n        lat3 = Number.parseFloat(lat3).toFixed(5);\r\n        lng3 = Number.parseFloat(lng3).toFixed(5);\r\n        var filter = \"_geoRadius(\".concat(lat3, \", \").concat(lng3, \", \").concat(radius, \")\");\r\n        return { filter: filter };\r\n    }\r\n    return undefined;\r\n}\r\nfunction createGeoSearchContext(searchContext) {\r\n    var geoContext = {};\r\n    var aroundLatLng = searchContext.aroundLatLng, aroundLatLngViaIP = searchContext.aroundLatLngViaIP, aroundRadius = searchContext.aroundRadius, aroundPrecision = searchContext.aroundPrecision, minimumAroundRadius = searchContext.minimumAroundRadius, insideBoundingBox = searchContext.insideBoundingBox, insidePolygon = searchContext.insidePolygon;\r\n    if (aroundLatLng) {\r\n        geoContext.aroundLatLng = aroundLatLng;\r\n    }\r\n    if (aroundLatLngViaIP) {\r\n        console.warn('instant-meilisearch: `aroundLatLngViaIP` is not supported.');\r\n    }\r\n    if (aroundRadius) {\r\n        geoContext.aroundRadius = aroundRadius;\r\n    }\r\n    if (aroundPrecision) {\r\n        console.warn(\"instant-meilisearch: `aroundPrecision` is not supported.\\n    See this discussion to track its implementation https://github.com/meilisearch/product/discussions/264\");\r\n    }\r\n    if (minimumAroundRadius) {\r\n        geoContext.minimumAroundRadius = minimumAroundRadius;\r\n    }\r\n    if (insideBoundingBox) {\r\n        geoContext.insideBoundingBox = insideBoundingBox;\r\n    }\r\n    // See related issue: https://github.com/meilisearch/instant-meilisearch/issues/555\r\n    if (insidePolygon) {\r\n        console.warn(\"instant-meilisearch: `insidePolygon` is not implented in instant-meilisearch.\");\r\n    }\r\n    return geoContext;\r\n}\n\n/**\r\n * Transform InstantSearch filter to Meilisearch filter.\r\n * Change sign from `:` to `=` in nested filter object.\r\n * example: [`genres:comedy`] becomes [`genres=comedy`]\r\n *\r\n * @param  {SearchContext['facetFilters']} filters?\r\n * @returns {Filter}\r\n */\r\nfunction transformFilter(filters) {\r\n    if (typeof filters === 'string') {\r\n        return replaceColonByEqualSign(filters);\r\n    }\r\n    else if (Array.isArray(filters))\r\n        return filters\r\n            .map(function (filter) {\r\n            if (Array.isArray(filter))\r\n                return filter\r\n                    .map(function (nestedFilter) { return replaceColonByEqualSign(nestedFilter); })\r\n                    .filter(function (elem) { return elem; });\r\n            else {\r\n                return replaceColonByEqualSign(filter);\r\n            }\r\n        })\r\n            .filter(function (elem) { return elem; });\r\n    return [];\r\n}\r\n/**\r\n * Return the filter in an array if it is a string\r\n * If filter is array, return without change.\r\n *\r\n * @param  {Filter} filter\r\n * @returns {Array}\r\n */\r\nfunction filterToArray(filter) {\r\n    // Filter is a string\r\n    if (filter === '')\r\n        return [];\r\n    else if (typeof filter === 'string')\r\n        return [filter];\r\n    // Filter is either an array of strings, or an array of array of strings\r\n    return filter;\r\n}\r\n/**\r\n * Merge facetFilters, numericFilters and filters together.\r\n *\r\n * @param  {Filter} facetFilters\r\n * @param  {Filter} numericFilters\r\n * @param  {string} filters\r\n * @returns {Filter}\r\n */\r\nfunction mergeFilters(facetFilters, numericFilters, filters) {\r\n    var adaptedFilters = filters.trim();\r\n    var adaptedFacetFilters = filterToArray(facetFilters);\r\n    var adaptedNumericFilters = filterToArray(numericFilters);\r\n    var adaptedFilter = __spreadArray(__spreadArray(__spreadArray([], adaptedFacetFilters, true), adaptedNumericFilters, true), [\r\n        adaptedFilters,\r\n    ]);\r\n    var cleanedFilters = adaptedFilter.filter(function (filter) {\r\n        if (Array.isArray(filter)) {\r\n            return filter.length;\r\n        }\r\n        return filter;\r\n    });\r\n    return cleanedFilters;\r\n}\r\n/**\r\n * Adapt instantsearch.js filters to Meilisearch filters by\r\n * combining and transforming all provided filters.\r\n *\r\n * @param  {string|undefined} filters\r\n * @param  {SearchContext['numericFilters']} numericFilters\r\n * @param  {SearchContext['facetFilters']} facetFilters\r\n * @returns {Filter}\r\n */\r\nfunction adaptFilters(filters, numericFilters, facetFilters) {\r\n    var transformedFilter = transformFilter(facetFilters || []);\r\n    var transformedNumericFilter = transformFilter(numericFilters || []);\r\n    return mergeFilters(transformedFilter, transformedNumericFilter, filters || '');\r\n}\n\n/**\r\n * Adapt search request from instantsearch.js\r\n * to search request compliant with Meilisearch\r\n *\r\n * @param  {SearchContext} searchContext\r\n * @returns {MeiliSearchParams}\r\n */\r\nfunction adaptSearchParams(searchContext) {\r\n    // Creates search params object compliant with Meilisearch\r\n    var meiliSearchParams = {};\r\n    // Facets\r\n    var facets = searchContext === null || searchContext === void 0 ? void 0 : searchContext.facets;\r\n    if (facets === null || facets === void 0 ? void 0 : facets.length) {\r\n        meiliSearchParams.facetsDistribution = facets;\r\n    }\r\n    // Attributes To Crop\r\n    var attributesToCrop = searchContext === null || searchContext === void 0 ? void 0 : searchContext.attributesToSnippet;\r\n    if (attributesToCrop) {\r\n        meiliSearchParams.attributesToCrop = attributesToCrop;\r\n    }\r\n    // Attributes To Crop marker\r\n    var cropMarker = searchContext === null || searchContext === void 0 ? void 0 : searchContext.snippetEllipsisText;\r\n    if (cropMarker != null) {\r\n        meiliSearchParams.cropMarker = cropMarker;\r\n    }\r\n    // Attributes To Retrieve\r\n    var attributesToRetrieve = searchContext === null || searchContext === void 0 ? void 0 : searchContext.attributesToRetrieve;\r\n    if (attributesToRetrieve) {\r\n        meiliSearchParams.attributesToRetrieve = attributesToRetrieve;\r\n    }\r\n    // Filter\r\n    var filter = adaptFilters(searchContext === null || searchContext === void 0 ? void 0 : searchContext.filters, searchContext === null || searchContext === void 0 ? void 0 : searchContext.numericFilters, searchContext === null || searchContext === void 0 ? void 0 : searchContext.facetFilters);\r\n    if (filter.length) {\r\n        meiliSearchParams.filter = filter;\r\n    }\r\n    // Attributes To Retrieve\r\n    if (attributesToRetrieve) {\r\n        meiliSearchParams.attributesToCrop = attributesToRetrieve;\r\n    }\r\n    // Attributes To Highlight\r\n    meiliSearchParams.attributesToHighlight = (searchContext === null || searchContext === void 0 ? void 0 : searchContext.attributesToHighlight) || [\r\n        '*',\r\n    ];\r\n    // Highlight pre tag\r\n    var highlightPreTag = searchContext === null || searchContext === void 0 ? void 0 : searchContext.highlightPreTag;\r\n    if (highlightPreTag) {\r\n        meiliSearchParams.highlightPreTag = highlightPreTag;\r\n    }\r\n    else {\r\n        meiliSearchParams.highlightPreTag = '__ais-highlight__';\r\n    }\r\n    // Highlight post tag\r\n    var highlightPostTag = searchContext === null || searchContext === void 0 ? void 0 : searchContext.highlightPostTag;\r\n    if (highlightPostTag) {\r\n        meiliSearchParams.highlightPostTag = highlightPostTag;\r\n    }\r\n    else {\r\n        meiliSearchParams.highlightPostTag = '__/ais-highlight__';\r\n    }\r\n    var placeholderSearch = searchContext.placeholderSearch;\r\n    var query = searchContext.query;\r\n    // Pagination\r\n    var pagination = searchContext.pagination;\r\n    // Limit based on pagination preferences\r\n    if ((!placeholderSearch && query === '') ||\r\n        pagination.paginationTotalHits === 0) {\r\n        meiliSearchParams.limit = 0;\r\n    }\r\n    else if (searchContext.finitePagination) {\r\n        meiliSearchParams.limit = pagination.paginationTotalHits;\r\n    }\r\n    else {\r\n        var limit = (pagination.page + 1) * pagination.hitsPerPage + 1;\r\n        // If the limit is bigger than the total hits accepted\r\n        // force the limit to that amount\r\n        if (limit > pagination.paginationTotalHits) {\r\n            meiliSearchParams.limit = pagination.paginationTotalHits;\r\n        }\r\n        else {\r\n            meiliSearchParams.limit = limit;\r\n        }\r\n    }\r\n    var sort = searchContext.sort;\r\n    // Sort\r\n    if (sort === null || sort === void 0 ? void 0 : sort.length) {\r\n        meiliSearchParams.sort = [sort];\r\n    }\r\n    var geoSearchContext = createGeoSearchContext(searchContext);\r\n    var geoRules = adaptGeoPointsRules(geoSearchContext);\r\n    if (geoRules === null || geoRules === void 0 ? void 0 : geoRules.filter) {\r\n        if (meiliSearchParams.filter) {\r\n            meiliSearchParams.filter.unshift(geoRules.filter);\r\n        }\r\n        else {\r\n            meiliSearchParams.filter = [geoRules.filter];\r\n        }\r\n    }\r\n    return meiliSearchParams;\r\n}\n\n/**\r\n * Slice the requested hits based on the pagination position.\r\n *\r\n * @param  {Record<string} hits\r\n * @param  {number} page\r\n * @param  {number} hitsPerPage\r\n * @returns {Array}\r\n */\r\nfunction adaptPagination(hits, page, hitsPerPage) {\r\n    if (hitsPerPage < 0) {\r\n        throw new TypeError('Value too small for \"hitsPerPage\" parameter, expected integer between 0 and 9223372036854775807');\r\n    }\r\n    var start = page * hitsPerPage;\r\n    return hits.slice(start, start + hitsPerPage);\r\n}\n\n/**\r\n * Stringify values following instantsearch practices.\r\n *\r\n * @param  {any} value - value that needs to be stringified\r\n */\r\nfunction stringifyValue(value) {\r\n    if (typeof value === 'string') {\r\n        // String\r\n        return value;\r\n    }\r\n    else if (value === undefined) {\r\n        // undefined\r\n        return JSON.stringify(null);\r\n    }\r\n    else {\r\n        return JSON.stringify(value);\r\n    }\r\n}\r\n/**\r\n * Recursif function wrap the deepest possible value\r\n * the following way: { value: \"xx\" }.\r\n *\r\n * For example:\r\n *\r\n * {\r\n * \"rootField\": { \"value\": \"x\" }\r\n * \"nestedField\": { child: { value: \"y\" } }\r\n * }\r\n *\r\n * recursivity continues until the value is not an array or an object.\r\n *\r\n * @param  {any} value - value of a field\r\n *\r\n * @returns Record<string, any>\r\n */\r\nfunction wrapValue(value) {\r\n    if (Array.isArray(value)) {\r\n        // Array\r\n        return value.map(function (elem) { return wrapValue(elem); });\r\n    }\r\n    else if (isPureObject(value)) {\r\n        // Object\r\n        return Object.keys(value).reduce(function (nested, key) {\r\n            nested[key] = wrapValue(value[key]);\r\n            return nested;\r\n        }, {});\r\n    }\r\n    else {\r\n        return { value: stringifyValue(value) };\r\n    }\r\n}\r\n/**\r\n * Adapt Meilisearch formatted fields to a format compliant to instantsearch.js.\r\n *\r\n * @param  {Record<string} formattedHit\r\n * @param  {SearchContext} searchContext\r\n * @returns {Record}\r\n */\r\nfunction adaptFormattedFields(hit) {\r\n    if (!hit)\r\n        return {};\r\n    var _formattedResult = wrapValue(hit);\r\n    var highlightedHit = {\r\n        // We could not determine what the differences are between those two fields.\r\n        _highlightResult: _formattedResult,\r\n        _snippetResult: _formattedResult\r\n    };\r\n    return highlightedHit;\r\n}\n\n/**\r\n * @param  {any[]} hits\r\n * @returns {Array<Record<string, any>>}\r\n */\r\nfunction adaptGeoResponse(hits) {\r\n    for (var i = 0; i < hits.length; i++) {\r\n        if (hits[i]._geo) {\r\n            hits[i]._geoloc = {\r\n                lat: hits[i]._geo.lat,\r\n                lng: hits[i]._geo.lng\r\n            };\r\n            hits[i].objectID = \"\".concat(i + Math.random() * 1000000);\r\n            delete hits[i]._geo;\r\n        }\r\n    }\r\n    return hits;\r\n}\n\n/**\r\n * @param  {Array<Record<string} hits\r\n * @param  {SearchContext} searchContext\r\n * @param  {PaginationContext} paginationContext\r\n * @returns {any}\r\n */\r\nfunction adaptHits(hits, searchContext, paginationContext) {\r\n    var primaryKey = searchContext.primaryKey;\r\n    var hitsPerPage = paginationContext.hitsPerPage, page = paginationContext.page;\r\n    var paginatedHits = adaptPagination(hits, page, hitsPerPage);\r\n    var adaptedHits = paginatedHits.map(function (hit) {\r\n        // Creates Hit object compliant with InstantSearch\r\n        if (Object.keys(hit).length > 0) {\r\n            var formattedHit = hit._formatted; hit._matchesInfo; var documentFields = __rest(hit, [\"_formatted\", \"_matchesInfo\"]);\r\n            var adaptedHit = Object.assign(documentFields, adaptFormattedFields(formattedHit));\r\n            if (primaryKey) {\r\n                adaptedHit.objectID = hit[primaryKey];\r\n            }\r\n            return adaptedHit;\r\n        }\r\n        return hit;\r\n    });\r\n    adaptedHits = adaptGeoResponse(adaptedHits);\r\n    return adaptedHits;\r\n}\n\n/**\r\n * Adapt search response from Meilisearch\r\n * to search response compliant with instantsearch.js\r\n *\r\n * @param  {MeiliSearchResponse<Record<string} searchResponse\r\n * @param  {SearchContext} searchContext\r\n * @param  {PaginationContext} paginationContext\r\n * @returns {{ results: Array<AlgoliaSearchResponse<T>> }}\r\n */\r\nfunction adaptSearchResponse(searchResponse, searchContext) {\r\n    var searchResponseOptionals = {};\r\n    var facets = searchResponse.facetsDistribution;\r\n    var pagination = searchContext.pagination;\r\n    var exhaustiveFacetsCount = searchResponse === null || searchResponse === void 0 ? void 0 : searchResponse.exhaustiveFacetsCount;\r\n    if (exhaustiveFacetsCount) {\r\n        searchResponseOptionals.exhaustiveFacetsCount = exhaustiveFacetsCount;\r\n    }\r\n    var nbPages = ceiledDivision(searchResponse.hits.length, pagination.hitsPerPage);\r\n    var hits = adaptHits(searchResponse.hits, searchContext, pagination);\r\n    var exhaustiveNbHits = searchResponse.exhaustiveNbHits;\r\n    var nbHits = searchResponse.nbHits;\r\n    var processingTimeMs = searchResponse.processingTimeMs;\r\n    var query = searchResponse.query;\r\n    var hitsPerPage = pagination.hitsPerPage, page = pagination.page;\r\n    // Create response object compliant with InstantSearch\r\n    var adaptedSearchResponse = __assign({ index: searchContext.indexUid, hitsPerPage: hitsPerPage, page: page, facets: facets, nbPages: nbPages, exhaustiveNbHits: exhaustiveNbHits, nbHits: nbHits, processingTimeMS: processingTimeMs, query: query, hits: hits, params: '' }, searchResponseOptionals);\r\n    return {\r\n        results: [adaptedSearchResponse]\r\n    };\r\n}\n\n/**\r\n * @param  {AlgoliaMultipleQueriesQuery} searchRequest\r\n * @param  {Context} options\r\n * @returns {SearchContext}\r\n */\r\nfunction createPaginationContext(_a) {\r\n    var paginationTotalHits = _a.paginationTotalHits, hitsPerPage = _a.hitsPerPage, page = _a.page;\r\n    return {\r\n        paginationTotalHits: paginationTotalHits != null ? paginationTotalHits : 200,\r\n        hitsPerPage: hitsPerPage === undefined ? 20 : hitsPerPage,\r\n        page: page || 0\r\n    };\r\n}\n\n/**\r\n * @param  {AlgoliaMultipleQueriesQuery} searchRequest\r\n * @param  {Context} options\r\n * @returns {SearchContext}\r\n */\r\nfunction createSearchContext(searchRequest, options, defaultFacetDistribution) {\r\n    // Split index name and possible sorting rules\r\n    var _a = searchRequest.indexName.split(':'), indexUid = _a[0], sortByArray = _a.slice(1);\r\n    var instantSearchParams = searchRequest.params;\r\n    var pagination = createPaginationContext({\r\n        paginationTotalHits: options.paginationTotalHits,\r\n        hitsPerPage: instantSearchParams === null || instantSearchParams === void 0 ? void 0 : instantSearchParams.hitsPerPage,\r\n        page: instantSearchParams === null || instantSearchParams === void 0 ? void 0 : instantSearchParams.page\r\n    });\r\n    var searchContext = __assign(__assign(__assign({}, options), instantSearchParams), { sort: sortByArray.join(':') || '', indexUid: indexUid, pagination: pagination, defaultFacetDistribution: defaultFacetDistribution, placeholderSearch: options.placeholderSearch !== false, keepZeroFacets: !!options.keepZeroFacets, finitePagination: !!options.finitePagination });\r\n    return searchContext;\r\n}\n\n/**\r\n * @param  {Record<string} cache\r\n * @returns {SearchCache}\r\n */\r\nfunction SearchCache(cache) {\r\n    if (cache === void 0) { cache = {}; }\r\n    var searchCache = cache;\r\n    return {\r\n        getEntry: function (key) {\r\n            if (searchCache[key]) {\r\n                try {\r\n                    return JSON.parse(searchCache[key]);\r\n                }\r\n                catch (_) {\r\n                    return searchCache[key];\r\n                }\r\n            }\r\n            return undefined;\r\n        },\r\n        formatKey: function (components) {\r\n            return stringifyArray(components);\r\n        },\r\n        setEntry: function (key, searchResponse) {\r\n            searchCache[key] = JSON.stringify(searchResponse);\r\n        }\r\n    };\r\n}\n\nfunction cacheFirstFacetsDistribution(defaultFacetDistribution, searchResponse) {\r\n    if (searchResponse.query === '' &&\r\n        Object.keys(defaultFacetDistribution).length === 0) {\r\n        return searchResponse.facetsDistribution;\r\n    }\r\n    return defaultFacetDistribution;\r\n}\n\n/**\r\n * Instanciate SearchClient required by instantsearch.js.\r\n *\r\n * @param  {string} hostUrl\r\n * @param  {string} apiKey\r\n * @param  {InstantMeiliSearchOptions={}} meiliSearchOptions\r\n * @returns {InstantMeiliSearchInstance}\r\n */\r\nfunction instantMeiliSearch(hostUrl, apiKey, instantMeiliSearchOptions) {\r\n    if (apiKey === void 0) { apiKey = ''; }\r\n    if (instantMeiliSearchOptions === void 0) { instantMeiliSearchOptions = {}; }\r\n    // create search resolver with included cache\r\n    var searchResolver = SearchResolver(SearchCache());\r\n    // paginationTotalHits can be 0 as it is a valid number\r\n    var defaultFacetDistribution = {};\r\n    var meilisearchClient = new meilisearch__WEBPACK_IMPORTED_MODULE_0__.MeiliSearch({ host: hostUrl, apiKey: apiKey });\r\n    return {\r\n        /**\r\n         * @param  {readonlyAlgoliaMultipleQueriesQuery[]} instantSearchRequests\r\n         * @returns {Array}\r\n         */\r\n        search: function (instantSearchRequests) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var searchRequest, searchContext, adaptedSearchRequest, searchResponse, adaptedSearchResponse, e_1;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            _a.trys.push([0, 2, , 3]);\r\n                            searchRequest = instantSearchRequests[0];\r\n                            searchContext = createSearchContext(searchRequest, instantMeiliSearchOptions, defaultFacetDistribution);\r\n                            adaptedSearchRequest = adaptSearchParams(searchContext);\r\n                            return [4 /*yield*/, searchResolver.searchResponse(searchContext, adaptedSearchRequest, meilisearchClient)\r\n                                // Cache first facets distribution of the instantMeilisearch instance\r\n                                // Needed to add in the facetsDistribution the fields that were not returned\r\n                                // When the user sets `keepZeroFacets` to true.\r\n                            ];\r\n                        case 1:\r\n                            searchResponse = _a.sent();\r\n                            // Cache first facets distribution of the instantMeilisearch instance\r\n                            // Needed to add in the facetsDistribution the fields that were not returned\r\n                            // When the user sets `keepZeroFacets` to true.\r\n                            defaultFacetDistribution = cacheFirstFacetsDistribution(defaultFacetDistribution, searchResponse);\r\n                            adaptedSearchResponse = adaptSearchResponse(searchResponse, searchContext);\r\n                            return [2 /*return*/, adaptedSearchResponse];\r\n                        case 2:\r\n                            e_1 = _a.sent();\r\n                            console.error(e_1);\r\n                            throw new Error(e_1);\r\n                        case 3: return [2 /*return*/];\r\n                    }\r\n                });\r\n            });\r\n        },\r\n        searchForFacetValues: function (_) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {\r\n                                reject(new Error('SearchForFacetValues is not compatible with Meilisearch'));\r\n                                resolve([]); // added here to avoid compilation error\r\n                            })];\r\n                        case 1: return [2 /*return*/, _a.sent()];\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    };\r\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1laWxpc2VhcmNoL2luc3RhbnQtbWVpbGlzZWFyY2gvZGlzdC9pbnN0YW50LW1laWxpc2VhcmNoLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLFlBQVksaUNBQWlDO0FBQzdDLFlBQVksK0JBQStCO0FBQzNDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNB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Ly9tZWR1c2EtbmV4dC8uL25vZGVfbW9kdWxlcy9AbWVpbGlzZWFyY2gvaW5zdGFudC1tZWlsaXNlYXJjaC9kaXN0L2luc3RhbnQtbWVpbGlzZWFyY2guZXNtLmpzPzhmNjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVpbGlTZWFyY2ggfSBmcm9tICdtZWlsaXNlYXJjaCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXHJcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xyXG4gICAgcmV0dXJuIHRvO1xyXG59XG5cbnZhciByZW1vdmVVbmRlZmluZWQgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gdW5kZWZpbmVkOyB9KTtcclxufTtcblxuLyoqXHJcbiAqIEBwYXJhbSAge2FueX0gc3RyXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuLyoqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsdGVyXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiByZXBsYWNlQ29sb25CeUVxdWFsU2lnbihmaWx0ZXIpIHtcclxuICAgIC8vIHdpbGwgb25seSBjaGFuZ2UgZmlyc3Qgb2NjdXJlbmNlIG9mIGA6YFxyXG4gICAgcmV0dXJuIGZpbHRlci5yZXBsYWNlKC86KC4qKS9pLCAnPVwiJDFcIicpO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gIHthbnlbXX0gYXJyXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheShhcnIpIHtcclxuICAgIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnIpIHtcclxuICAgICAgICByZXR1cm4gKGFjYyArPSBKU09OLnN0cmluZ2lmeShjdXJyKSk7XHJcbiAgICB9LCAnJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSAge251bWJlcn0gZGl2aWRlbmRcclxuICogQHBhcmFtICB7bnVtYmVyfSBkaXZpc29yXHJcbiAqIEByZXR1cm5zIG51bWJlclxyXG4gKi9cclxuZnVuY3Rpb24gY2VpbGVkRGl2aXNpb24oZGl2aWRlbmQsIGRpdmlzb3IpIHtcclxuICAgIGlmIChkaXZpc29yID4gMCkge1xyXG4gICAgICAgIHZhciBOdW1iZXJQYWdlcyA9IE1hdGguY2VpbChkaXZpZGVuZCAvIGRpdmlzb3IpOyAvLyB0b3RhbCBudW1iZXIgb2YgcGFnZXMgcm91bmRlZCB1cCB0byB0aGUgbmV4dCBsYXJnZXN0IGludGVnZXIuXHJcbiAgICAgICAgcmV0dXJuIE51bWJlclBhZ2VzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cblxuZnVuY3Rpb24gaXNQdXJlT2JqZWN0KGRhdGEpIHtcclxuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSkgJiYgZGF0YSAhPT0gbnVsbDtcclxufVxuXG4vKipcclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWx0ZXJcclxuICovXHJcbnZhciBhZGFwdEZpbHRlclN5bnRheCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgIHZhciBtYXRjaGVzID0gZmlsdGVyLm1hdGNoKC8oW149XSopPVwiPyhbXlxcXFxcIl0qKVwiPyQvKTtcclxuICAgIGlmIChtYXRjaGVzKSB7XHJcbiAgICAgICAgbWF0Y2hlc1swXTsgdmFyIGZpbHRlck5hbWUgPSBtYXRjaGVzWzFdLCB2YWx1ZSA9IG1hdGNoZXNbMl07XHJcbiAgICAgICAgcmV0dXJuIFt7IGZpbHRlck5hbWU6IGZpbHRlck5hbWUsIHZhbHVlOiB2YWx1ZSB9XTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxufTtcclxuLyoqXHJcbiAqIEBwYXJhbSAge0ZpbHRlcn0gZmlsdGVycz9cclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdEZpbHRlcnMoZmlsdGVycykge1xyXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXJzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBhZGFwdEZpbHRlclN5bnRheChmaWx0ZXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVycykpIHtcclxuICAgICAgICByZXR1cm4gZmlsdGVyc1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChuZXN0ZWRGaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmVzdGVkRmlsdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3RlZEZpbHRlci5tYXAoZnVuY3Rpb24gKGZpbHRlcikgeyByZXR1cm4gYWRhcHRGaWx0ZXJTeW50YXgoZmlsdGVyKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0RmlsdGVyU3ludGF4KG5lc3RlZEZpbHRlcik7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZsYXQoMik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSAge0ZpbHRlcn0gZmlsdGVycz9cclxuICogQHJldHVybnMge0ZhY2V0c0NhY2hlfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RmFjZXRzRnJvbUZpbHRlcihmaWx0ZXJzKSB7XHJcbiAgICB2YXIgZXh0cmFjdGVkRmlsdGVycyA9IGV4dHJhY3RGaWx0ZXJzKGZpbHRlcnMpO1xyXG4gICAgdmFyIGNsZWFuRmlsdGVycyA9IHJlbW92ZVVuZGVmaW5lZChleHRyYWN0ZWRGaWx0ZXJzKTtcclxuICAgIHJldHVybiBjbGVhbkZpbHRlcnMucmVkdWNlKGZ1bmN0aW9uIChjYWNoZSwgcGFyc2VkRmlsdGVyKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBmaWx0ZXJOYW1lID0gcGFyc2VkRmlsdGVyLmZpbHRlck5hbWUsIHZhbHVlID0gcGFyc2VkRmlsdGVyLnZhbHVlO1xyXG4gICAgICAgIHZhciBwcmV2RmllbGRzID0gY2FjaGVbZmlsdGVyTmFtZV0gfHwgW107XHJcbiAgICAgICAgY2FjaGUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY2FjaGUpLCAoX2EgPSB7fSwgX2FbZmlsdGVyTmFtZV0gPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXZGaWVsZHMsIHRydWUpLCBbdmFsdWVdKSwgX2EpKTtcclxuICAgICAgICByZXR1cm4gY2FjaGU7XHJcbiAgICB9LCB7fSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RmFjZXRzRnJvbURlZmF1bHREaXN0cmlidXRpb24oZmFjZXRzRGlzdHJpYnV0aW9uKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZmFjZXRzRGlzdHJpYnV0aW9uKS5yZWR1Y2UoZnVuY3Rpb24gKGNhY2hlLCBmYWNldCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgZmFjZXRWYWx1ZXMgPSBPYmplY3Qua2V5cyhmYWNldHNEaXN0cmlidXRpb25bZmFjZXRdKTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGNhY2hlKSwgKF9hID0ge30sIF9hW2ZhY2V0XSA9IGZhY2V0VmFsdWVzLCBfYSkpO1xyXG4gICAgfSwge30pO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gIHtGaWx0ZXJ9IGZpbHRlcnM/XHJcbiAqIEByZXR1cm5zIHtGYWNldHNDYWNoZX1cclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RGYWNldHMoc2VhcmNoQ29udGV4dCwgc2VhcmNoUGFyYW1zKSB7XHJcbiAgICBpZiAoc2VhcmNoQ29udGV4dC5rZWVwWmVyb0ZhY2V0cykge1xyXG4gICAgICAgIHJldHVybiBnZXRGYWNldHNGcm9tRGVmYXVsdERpc3RyaWJ1dGlvbihzZWFyY2hDb250ZXh0LmRlZmF1bHRGYWNldERpc3RyaWJ1dGlvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZ2V0RmFjZXRzRnJvbUZpbHRlcihzZWFyY2hQYXJhbXMgPT09IG51bGwgfHwgc2VhcmNoUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hQYXJhbXMuZmlsdGVyKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXNzaWduIG1pc3NpbmcgZmlsdGVycyB0byBmYWNldHNEaXN0cmlidXRpb24uXHJcbiAqIEFsbCBmYWNldCBwYXNzZWQgYXMgZmlsdGVyIHNob3VsZCBhcHBlYXIgaW4gdGhlIGZhY2V0c0Rpc3RyaWJ1dGlvbi5cclxuICogSWYgbm90IHByZXNlbnQsIHRoZSBmYWNldCBpcyBhZGRlZCB3aXRoIDAgYXMgdmFsdWUuXHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSAge0ZhY2V0c0NhY2hlfSBjYWNoZT9cclxuICogQHBhcmFtICB7RmFjZXRzRGlzdHJpYnV0aW9ufSBkaXN0cmlidXRpb24/XHJcbiAqIEByZXR1cm5zIHtGYWNldHNEaXN0cmlidXRpb259XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRNaXNzaW5nRmFjZXRzKGNhY2hlZEZhY2V0cywgZGlzdHJpYnV0aW9uKSB7XHJcbiAgICBkaXN0cmlidXRpb24gPSBkaXN0cmlidXRpb24gfHwge307XHJcbiAgICAvLyBJZiBjYWNoZWRGYWNldHMgY29udGFpbnMgc29tZXRoaW5nXHJcbiAgICBpZiAoY2FjaGVkRmFjZXRzICYmIE9iamVjdC5rZXlzKGNhY2hlZEZhY2V0cykubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIGZvciBhbGwgZmlsdGVycyBpbiBjYWNoZWQgZmlsdGVyc1xyXG4gICAgICAgIGZvciAodmFyIGNhY2hlZEZhY2V0IGluIGNhY2hlZEZhY2V0cykge1xyXG4gICAgICAgICAgICAvLyBpZiBmYWNldCBkb2VzIG5vdCBleGlzdCBvbiByZXR1cm5lZCBkaXN0cmlidXRpb24sIGFkZCBhbiBlbXB0eSBvYmplY3RcclxuICAgICAgICAgICAgaWYgKCFkaXN0cmlidXRpb25bY2FjaGVkRmFjZXRdKVxyXG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uW2NhY2hlZEZhY2V0XSA9IHt9O1xyXG4gICAgICAgICAgICAvLyBmb3IgYWxsIGZpZWxkcyBpbiBldmVyeSBmaWx0ZXJcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNhY2hlZEZhY2V0c1tjYWNoZWRGYWNldF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkRmllbGQgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmllbGQgaXMgbm90IHByZXNlbnQgaW4gdGhlIHJldHVybmVkIGRpc3RyaWJ1dGlvblxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IGl0IGF0IDBcclxuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZGlzdHJpYnV0aW9uW2NhY2hlZEZhY2V0XSkuaW5jbHVkZXMoY2FjaGVkRmllbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIDAgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25bY2FjaGVkRmFjZXRdW2NhY2hlZEZpZWxkXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGlzdHJpYnV0aW9uO1xyXG59XG5cbnZhciBlbXB0eVNlYXJjaCA9IHtcclxuICAgIGhpdHM6IFtdLFxyXG4gICAgcXVlcnk6ICcnLFxyXG4gICAgZmFjZXRzRGlzdHJpYnV0aW9uOiB7fSxcclxuICAgIGxpbWl0OiAwLFxyXG4gICAgb2Zmc2V0OiAwLFxyXG4gICAgZXhoYXVzdGl2ZU5iSGl0czogZmFsc2UsXHJcbiAgICBuYkhpdHM6IDAsXHJcbiAgICBwcm9jZXNzaW5nVGltZU1zOiAwXHJcbn07XHJcbi8qKlxyXG4gKiBAcGFyYW0gIHtSZXNwb25zZUNhY2hlcn0gY2FjaGVcclxuICovXHJcbmZ1bmN0aW9uIFNlYXJjaFJlc29sdmVyKGNhY2hlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSAge1NlYXJjaENvbnRleHR9IHNlYXJjaENvbnRleHRcclxuICAgICAgICAgKiBAcGFyYW0gIHtNZWlsaVNlYXJjaFBhcmFtc30gc2VhcmNoUGFyYW1zXHJcbiAgICAgICAgICogQHBhcmFtICB7TWVpbGlTZWFyY2h9IGNsaWVudFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNlYXJjaFJlc3BvbnNlOiBmdW5jdGlvbiAoc2VhcmNoQ29udGV4dCwgc2VhcmNoUGFyYW1zLCBjbGllbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyU2VhcmNoLCBxdWVyeSwgcGFnaW5hdGlvbiwgcGFnaW5hdGlvbkNhY2hlLCBrZXksIGNhY2hlZFJlc3BvbnNlLCBmYWNldHNDYWNoZSwgc2VhcmNoUmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlclNlYXJjaCA9IHNlYXJjaENvbnRleHQucGxhY2Vob2xkZXJTZWFyY2gsIHF1ZXJ5ID0gc2VhcmNoQ29udGV4dC5xdWVyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHF1ZXJ5IGNhbiBiZTogZW1wdHkgc3RyaW5nLCB1bmRlZmluZWQgb3IgbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG9mIHRoZW0gYXJlIGZhbHN5J3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGxhY2Vob2xkZXJTZWFyY2ggJiYgIXF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGVtcHR5U2VhcmNoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2luYXRpb24gPSBzZWFyY2hDb250ZXh0LnBhZ2luYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uQ2FjaGUgPSBzZWFyY2hDb250ZXh0LmZpbml0ZVBhZ2luYXRpb24gPyB7fSA6IHBhZ2luYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBjYWNoZS5mb3JtYXRLZXkoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hDb250ZXh0LmluZGV4VWlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaENvbnRleHQucXVlcnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbkNhY2hlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRSZXNwb25zZSA9IGNhY2hlLmdldEVudHJ5KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBzcGVjaWZpYyByZXF1ZXN0IGlzIGFscmVhZHkgY2FjaGVkIHdpdGggaXRzIGFzc29jaWF0ZWQgc2VhcmNoIHJlc3BvbnNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjYWNoZWRSZXNwb25zZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNldHNDYWNoZSA9IGV4dHJhY3RGYWNldHMoc2VhcmNoQ29udGV4dCwgc2VhcmNoUGFyYW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNsaWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5kZXgoc2VhcmNoQ29udGV4dC5pbmRleFVpZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlYXJjaChzZWFyY2hDb250ZXh0LnF1ZXJ5LCBzZWFyY2hQYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG1pc3NpbmcgZmFjZXRzIGJhY2sgaW50byBmYWNldHNEaXN0cmlidXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFJlc3BvbnNlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG1pc3NpbmcgZmFjZXRzIGJhY2sgaW50byBmYWNldHNEaXN0cmlidXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFJlc3BvbnNlLmZhY2V0c0Rpc3RyaWJ1dGlvbiA9IGFkZE1pc3NpbmdGYWNldHMoZmFjZXRzQ2FjaGUsIHNlYXJjaFJlc3BvbnNlLmZhY2V0c0Rpc3RyaWJ1dGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0RW50cnkoa2V5LCBzZWFyY2hSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgc2VhcmNoUmVzcG9uc2VdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHJhZFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gcmFkMmRlZ3IocmFkKSB7XHJcbiAgICByZXR1cm4gKHJhZCAqIDE4MCkgLyBNYXRoLlBJO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRlZ3JcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGRlZ3IycmFkKGRlZ3IpIHtcclxuICAgIHJldHVybiAoZGVnciAqIE1hdGguUEkpIC8gMTgwO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxhdDFcclxuICogQHBhcmFtICB7bnVtYmVyfSBsbmcxXHJcbiAqIEBwYXJhbSAge251bWJlcn0gbGF0MlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxuZzJcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIG1pZGRsZUdlb1BvaW50cyhsYXQxLCBsbmcxLCBsYXQyLCBsbmcyKSB7XHJcbiAgICAvLyBjb252ZXJ0IHRvIHJhZGlhbnNcclxuICAgIGxhdDEgPSBkZWdyMnJhZChsYXQxKTtcclxuICAgIGxuZzEgPSBkZWdyMnJhZChsbmcxKTtcclxuICAgIHZhciB4MSA9IE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobG5nMSk7XHJcbiAgICB2YXIgeTEgPSBNYXRoLmNvcyhsYXQxKSAqIE1hdGguc2luKGxuZzEpO1xyXG4gICAgdmFyIHoxID0gTWF0aC5zaW4obGF0MSk7XHJcbiAgICAvLyBjb252ZXJ0IHRvIHJhZGlhbnNcclxuICAgIGxhdDIgPSBkZWdyMnJhZChsYXQyKTtcclxuICAgIGxuZzIgPSBkZWdyMnJhZChsbmcyKTtcclxuICAgIHZhciB4MiA9IE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG5nMik7XHJcbiAgICB2YXIgeTIgPSBNYXRoLmNvcyhsYXQyKSAqIE1hdGguc2luKGxuZzIpO1xyXG4gICAgdmFyIHoyID0gTWF0aC5zaW4obGF0Mik7XHJcbiAgICB2YXIgeCA9IHgxICsgeDI7XHJcbiAgICB2YXIgeSA9IHkxICsgeTI7XHJcbiAgICB2YXIgeiA9IHoxICsgejI7XHJcbiAgICB2YXIgSHlwID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG4gICAgdmFyIGxuZzMgPSBNYXRoLmF0YW4yKHksIHgpO1xyXG4gICAgdmFyIGxhdDMgPSBNYXRoLmF0YW4yKHosIEh5cCk7XHJcbiAgICBpZiAobG5nMSA8IGxuZzIgfHwgKGxuZzEgPiBsbmcyICYmIGxuZzEgPiBNYXRoLlBJICYmIGxuZzIgPCAtTWF0aC5QSSkpIHtcclxuICAgICAgICBsYXQzID0gbGF0MyArIE1hdGguUEk7XHJcbiAgICAgICAgbG5nMyA9IGxuZzMgKyBNYXRoLlBJO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGF0MyA9IHJhZDJkZWdyKGxhdDMpO1xyXG4gICAgICAgIGxuZzMgPSByYWQyZGVncihsbmczKTtcclxuICAgIH1cclxuICAgIGlmIChNYXRoLmFicyh4KSA8IE1hdGgucG93KDEwLCAtOSkgJiZcclxuICAgICAgICBNYXRoLmFicyh5KSA8IE1hdGgucG93KDEwLCAtOSkgJiZcclxuICAgICAgICBNYXRoLmFicyh6KSA8IE1hdGgucG93KDEwLCAtOSkpIHtcclxuICAgICAgICBsYXQzID0gMDtcclxuICAgICAgICBsbmczID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBcIlwiLmNvbmNhdChsYXQzLCBcIixcIikuY29uY2F0KGxuZzMpO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxhdDFcclxuICogQHBhcmFtICB7bnVtYmVyfSBsbmcxXHJcbiAqIEBwYXJhbSAge251bWJlcn0gbGF0MlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxuZzJcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldERpc3RhbmNlSW5NZXRlcihsYXQxLCBsbmcxLCBsYXQyLCBsbmcyKSB7XHJcbiAgICAvLyBIYXZlcnNpbmUgQWxnb3JpdGhtXHJcbiAgICB2YXIgUiA9IDYzNzFlMzsgLy8gbWV0cmVzXHJcbiAgICB2YXIgbGF0UmFkMSA9IChsYXQxICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICB2YXIgbGF0UmFkMiA9IChsYXQyICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICB2YXIgbGF0Q2VudGVyUmFkID0gKChsYXQyIC0gbGF0MSkgKiBNYXRoLlBJKSAvIDE4MDtcclxuICAgIHZhciBsbmdDZW50ZXJSYWQgPSAoKGxuZzIgLSBsbmcxKSAqIE1hdGguUEkpIC8gMTgwO1xyXG4gICAgdmFyIGEgPSBNYXRoLnNpbihsYXRDZW50ZXJSYWQgLyAyKSAqIE1hdGguc2luKGxhdENlbnRlclJhZCAvIDIpICtcclxuICAgICAgICBNYXRoLmNvcyhsYXRSYWQxKSAqXHJcbiAgICAgICAgICAgIE1hdGguY29zKGxhdFJhZDIpICpcclxuICAgICAgICAgICAgTWF0aC5zaW4obG5nQ2VudGVyUmFkIC8gMikgKlxyXG4gICAgICAgICAgICBNYXRoLnNpbihsbmdDZW50ZXJSYWQgLyAyKTtcclxuICAgIHZhciBiZWFyaW5nID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcclxuICAgIHZhciBkaXN0YW5jZSA9IFIgKiBiZWFyaW5nOyAvLyBpbiBtZXRyZXNcclxuICAgIHJldHVybiBkaXN0YW5jZTtcclxufVxuXG5mdW5jdGlvbiBhZGFwdEdlb1BvaW50c1J1bGVzKGdlb1NlYXJjaENvbnRleHQpIHtcclxuICAgIGlmICghZ2VvU2VhcmNoQ29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICB2YXIgaW5zaWRlQm91bmRpbmdCb3ggPSBnZW9TZWFyY2hDb250ZXh0Lmluc2lkZUJvdW5kaW5nQm94LCBhcm91bmRMYXRMbmcgPSBnZW9TZWFyY2hDb250ZXh0LmFyb3VuZExhdExuZywgYXJvdW5kUmFkaXVzID0gZ2VvU2VhcmNoQ29udGV4dC5hcm91bmRSYWRpdXMsIG1pbmltdW1Bcm91bmRSYWRpdXMgPSBnZW9TZWFyY2hDb250ZXh0Lm1pbmltdW1Bcm91bmRSYWRpdXM7XHJcbiAgICB2YXIgbWlkZGxlUG9pbnQ7XHJcbiAgICB2YXIgcmFkaXVzO1xyXG4gICAgaWYgKGFyb3VuZExhdExuZykge1xyXG4gICAgICAgIG1pZGRsZVBvaW50ID0gYXJvdW5kTGF0TG5nO1xyXG4gICAgfVxyXG4gICAgaWYgKGFyb3VuZFJhZGl1cyAhPSBudWxsIHx8IG1pbmltdW1Bcm91bmRSYWRpdXMgIT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChhcm91bmRSYWRpdXMgIT0gbnVsbClcclxuICAgICAgICAgICAgcmFkaXVzID0gYXJvdW5kUmFkaXVzO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmFkaXVzID0gbWluaW11bUFyb3VuZFJhZGl1cztcclxuICAgIH1cclxuICAgIC8vIElmIGluc2lkZUJvdW5kaW5nQm94IGlzIHByb3ZpZGVkIGl0IHRha2VzIHByZWNlZGVudCBvdmVyIGFsbCBvdGhlciBvcHRpb25zXHJcbiAgICBpZiAoaW5zaWRlQm91bmRpbmdCb3ggJiYgdHlwZW9mIGluc2lkZUJvdW5kaW5nQm94ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHZhciBfYSA9IGluc2lkZUJvdW5kaW5nQm94LnNwbGl0KCcsJyksIGxhdDFSYXcgPSBfYVswXSwgbG5nMVJhdyA9IF9hWzFdLCBsYXQyUmF3ID0gX2FbMl0sIGxuZzJSYXcgPSBfYVszXTtcclxuICAgICAgICB2YXIgX2IgPSBbXHJcbiAgICAgICAgICAgIHBhcnNlRmxvYXQobGF0MVJhdyksXHJcbiAgICAgICAgICAgIHBhcnNlRmxvYXQobG5nMVJhdyksXHJcbiAgICAgICAgICAgIHBhcnNlRmxvYXQobGF0MlJhdyksXHJcbiAgICAgICAgICAgIHBhcnNlRmxvYXQobG5nMlJhdyksXHJcbiAgICAgICAgXSwgbGF0MSA9IF9iWzBdLCBsbmcxID0gX2JbMV0sIGxhdDIgPSBfYlsyXSwgbG5nMiA9IF9iWzNdO1xyXG4gICAgICAgIHJhZGl1cyA9IGdldERpc3RhbmNlSW5NZXRlcihsYXQxLCBsbmcxLCBsYXQyLCBsbmcyKSAvIDI7XHJcbiAgICAgICAgbWlkZGxlUG9pbnQgPSBtaWRkbGVHZW9Qb2ludHMobGF0MSwgbG5nMSwgbGF0MiwgbG5nMik7XHJcbiAgICB9XHJcbiAgICBpZiAobWlkZGxlUG9pbnQgIT0gbnVsbCAmJiByYWRpdXMgIT0gbnVsbCkge1xyXG4gICAgICAgIHZhciBfYyA9IG1pZGRsZVBvaW50LnNwbGl0KCcsJyksIGxhdDMgPSBfY1swXSwgbG5nMyA9IF9jWzFdO1xyXG4gICAgICAgIGxhdDMgPSBOdW1iZXIucGFyc2VGbG9hdChsYXQzKS50b0ZpeGVkKDUpO1xyXG4gICAgICAgIGxuZzMgPSBOdW1iZXIucGFyc2VGbG9hdChsbmczKS50b0ZpeGVkKDUpO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBcIl9nZW9SYWRpdXMoXCIuY29uY2F0KGxhdDMsIFwiLCBcIikuY29uY2F0KGxuZzMsIFwiLCBcIikuY29uY2F0KHJhZGl1cywgXCIpXCIpO1xyXG4gICAgICAgIHJldHVybiB7IGZpbHRlcjogZmlsdGVyIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUdlb1NlYXJjaENvbnRleHQoc2VhcmNoQ29udGV4dCkge1xyXG4gICAgdmFyIGdlb0NvbnRleHQgPSB7fTtcclxuICAgIHZhciBhcm91bmRMYXRMbmcgPSBzZWFyY2hDb250ZXh0LmFyb3VuZExhdExuZywgYXJvdW5kTGF0TG5nVmlhSVAgPSBzZWFyY2hDb250ZXh0LmFyb3VuZExhdExuZ1ZpYUlQLCBhcm91bmRSYWRpdXMgPSBzZWFyY2hDb250ZXh0LmFyb3VuZFJhZGl1cywgYXJvdW5kUHJlY2lzaW9uID0gc2VhcmNoQ29udGV4dC5hcm91bmRQcmVjaXNpb24sIG1pbmltdW1Bcm91bmRSYWRpdXMgPSBzZWFyY2hDb250ZXh0Lm1pbmltdW1Bcm91bmRSYWRpdXMsIGluc2lkZUJvdW5kaW5nQm94ID0gc2VhcmNoQ29udGV4dC5pbnNpZGVCb3VuZGluZ0JveCwgaW5zaWRlUG9seWdvbiA9IHNlYXJjaENvbnRleHQuaW5zaWRlUG9seWdvbjtcclxuICAgIGlmIChhcm91bmRMYXRMbmcpIHtcclxuICAgICAgICBnZW9Db250ZXh0LmFyb3VuZExhdExuZyA9IGFyb3VuZExhdExuZztcclxuICAgIH1cclxuICAgIGlmIChhcm91bmRMYXRMbmdWaWFJUCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignaW5zdGFudC1tZWlsaXNlYXJjaDogYGFyb3VuZExhdExuZ1ZpYUlQYCBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgfVxyXG4gICAgaWYgKGFyb3VuZFJhZGl1cykge1xyXG4gICAgICAgIGdlb0NvbnRleHQuYXJvdW5kUmFkaXVzID0gYXJvdW5kUmFkaXVzO1xyXG4gICAgfVxyXG4gICAgaWYgKGFyb3VuZFByZWNpc2lvbikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcImluc3RhbnQtbWVpbGlzZWFyY2g6IGBhcm91bmRQcmVjaXNpb25gIGlzIG5vdCBzdXBwb3J0ZWQuXFxuICAgIFNlZSB0aGlzIGRpc2N1c3Npb24gdG8gdHJhY2sgaXRzIGltcGxlbWVudGF0aW9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWlsaXNlYXJjaC9wcm9kdWN0L2Rpc2N1c3Npb25zLzI2NFwiKTtcclxuICAgIH1cclxuICAgIGlmIChtaW5pbXVtQXJvdW5kUmFkaXVzKSB7XHJcbiAgICAgICAgZ2VvQ29udGV4dC5taW5pbXVtQXJvdW5kUmFkaXVzID0gbWluaW11bUFyb3VuZFJhZGl1cztcclxuICAgIH1cclxuICAgIGlmIChpbnNpZGVCb3VuZGluZ0JveCkge1xyXG4gICAgICAgIGdlb0NvbnRleHQuaW5zaWRlQm91bmRpbmdCb3ggPSBpbnNpZGVCb3VuZGluZ0JveDtcclxuICAgIH1cclxuICAgIC8vIFNlZSByZWxhdGVkIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vbWVpbGlzZWFyY2gvaW5zdGFudC1tZWlsaXNlYXJjaC9pc3N1ZXMvNTU1XHJcbiAgICBpZiAoaW5zaWRlUG9seWdvbikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcImluc3RhbnQtbWVpbGlzZWFyY2g6IGBpbnNpZGVQb2x5Z29uYCBpcyBub3QgaW1wbGVudGVkIGluIGluc3RhbnQtbWVpbGlzZWFyY2guXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdlb0NvbnRleHQ7XHJcbn1cblxuLyoqXHJcbiAqIFRyYW5zZm9ybSBJbnN0YW50U2VhcmNoIGZpbHRlciB0byBNZWlsaXNlYXJjaCBmaWx0ZXIuXHJcbiAqIENoYW5nZSBzaWduIGZyb20gYDpgIHRvIGA9YCBpbiBuZXN0ZWQgZmlsdGVyIG9iamVjdC5cclxuICogZXhhbXBsZTogW2BnZW5yZXM6Y29tZWR5YF0gYmVjb21lcyBbYGdlbnJlcz1jb21lZHlgXVxyXG4gKlxyXG4gKiBAcGFyYW0gIHtTZWFyY2hDb250ZXh0WydmYWNldEZpbHRlcnMnXX0gZmlsdGVycz9cclxuICogQHJldHVybnMge0ZpbHRlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybUZpbHRlcihmaWx0ZXJzKSB7XHJcbiAgICBpZiAodHlwZW9mIGZpbHRlcnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VDb2xvbkJ5RXF1YWxTaWduKGZpbHRlcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJzKSlcclxuICAgICAgICByZXR1cm4gZmlsdGVyc1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChuZXN0ZWRGaWx0ZXIpIHsgcmV0dXJuIHJlcGxhY2VDb2xvbkJ5RXF1YWxTaWduKG5lc3RlZEZpbHRlcik7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbTsgfSk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VDb2xvbkJ5RXF1YWxTaWduKGZpbHRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtOyB9KTtcclxuICAgIHJldHVybiBbXTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIHRoZSBmaWx0ZXIgaW4gYW4gYXJyYXkgaWYgaXQgaXMgYSBzdHJpbmdcclxuICogSWYgZmlsdGVyIGlzIGFycmF5LCByZXR1cm4gd2l0aG91dCBjaGFuZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0ZpbHRlcn0gZmlsdGVyXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIGZpbHRlclRvQXJyYXkoZmlsdGVyKSB7XHJcbiAgICAvLyBGaWx0ZXIgaXMgYSBzdHJpbmdcclxuICAgIGlmIChmaWx0ZXIgPT09ICcnKVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHJldHVybiBbZmlsdGVyXTtcclxuICAgIC8vIEZpbHRlciBpcyBlaXRoZXIgYW4gYXJyYXkgb2Ygc3RyaW5ncywgb3IgYW4gYXJyYXkgb2YgYXJyYXkgb2Ygc3RyaW5nc1xyXG4gICAgcmV0dXJuIGZpbHRlcjtcclxufVxyXG4vKipcclxuICogTWVyZ2UgZmFjZXRGaWx0ZXJzLCBudW1lcmljRmlsdGVycyBhbmQgZmlsdGVycyB0b2dldGhlci5cclxuICpcclxuICogQHBhcmFtICB7RmlsdGVyfSBmYWNldEZpbHRlcnNcclxuICogQHBhcmFtICB7RmlsdGVyfSBudW1lcmljRmlsdGVyc1xyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbHRlcnNcclxuICogQHJldHVybnMge0ZpbHRlcn1cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlRmlsdGVycyhmYWNldEZpbHRlcnMsIG51bWVyaWNGaWx0ZXJzLCBmaWx0ZXJzKSB7XHJcbiAgICB2YXIgYWRhcHRlZEZpbHRlcnMgPSBmaWx0ZXJzLnRyaW0oKTtcclxuICAgIHZhciBhZGFwdGVkRmFjZXRGaWx0ZXJzID0gZmlsdGVyVG9BcnJheShmYWNldEZpbHRlcnMpO1xyXG4gICAgdmFyIGFkYXB0ZWROdW1lcmljRmlsdGVycyA9IGZpbHRlclRvQXJyYXkobnVtZXJpY0ZpbHRlcnMpO1xyXG4gICAgdmFyIGFkYXB0ZWRGaWx0ZXIgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgYWRhcHRlZEZhY2V0RmlsdGVycywgdHJ1ZSksIGFkYXB0ZWROdW1lcmljRmlsdGVycywgdHJ1ZSksIFtcclxuICAgICAgICBhZGFwdGVkRmlsdGVycyxcclxuICAgIF0pO1xyXG4gICAgdmFyIGNsZWFuZWRGaWx0ZXJzID0gYWRhcHRlZEZpbHRlci5maWx0ZXIoZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWx0ZXI7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjbGVhbmVkRmlsdGVycztcclxufVxyXG4vKipcclxuICogQWRhcHQgaW5zdGFudHNlYXJjaC5qcyBmaWx0ZXJzIHRvIE1laWxpc2VhcmNoIGZpbHRlcnMgYnlcclxuICogY29tYmluaW5nIGFuZCB0cmFuc2Zvcm1pbmcgYWxsIHByb3ZpZGVkIGZpbHRlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ3x1bmRlZmluZWR9IGZpbHRlcnNcclxuICogQHBhcmFtICB7U2VhcmNoQ29udGV4dFsnbnVtZXJpY0ZpbHRlcnMnXX0gbnVtZXJpY0ZpbHRlcnNcclxuICogQHBhcmFtICB7U2VhcmNoQ29udGV4dFsnZmFjZXRGaWx0ZXJzJ119IGZhY2V0RmlsdGVyc1xyXG4gKiBAcmV0dXJucyB7RmlsdGVyfVxyXG4gKi9cclxuZnVuY3Rpb24gYWRhcHRGaWx0ZXJzKGZpbHRlcnMsIG51bWVyaWNGaWx0ZXJzLCBmYWNldEZpbHRlcnMpIHtcclxuICAgIHZhciB0cmFuc2Zvcm1lZEZpbHRlciA9IHRyYW5zZm9ybUZpbHRlcihmYWNldEZpbHRlcnMgfHwgW10pO1xyXG4gICAgdmFyIHRyYW5zZm9ybWVkTnVtZXJpY0ZpbHRlciA9IHRyYW5zZm9ybUZpbHRlcihudW1lcmljRmlsdGVycyB8fCBbXSk7XHJcbiAgICByZXR1cm4gbWVyZ2VGaWx0ZXJzKHRyYW5zZm9ybWVkRmlsdGVyLCB0cmFuc2Zvcm1lZE51bWVyaWNGaWx0ZXIsIGZpbHRlcnMgfHwgJycpO1xyXG59XG5cbi8qKlxyXG4gKiBBZGFwdCBzZWFyY2ggcmVxdWVzdCBmcm9tIGluc3RhbnRzZWFyY2guanNcclxuICogdG8gc2VhcmNoIHJlcXVlc3QgY29tcGxpYW50IHdpdGggTWVpbGlzZWFyY2hcclxuICpcclxuICogQHBhcmFtICB7U2VhcmNoQ29udGV4dH0gc2VhcmNoQ29udGV4dFxyXG4gKiBAcmV0dXJucyB7TWVpbGlTZWFyY2hQYXJhbXN9XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGFwdFNlYXJjaFBhcmFtcyhzZWFyY2hDb250ZXh0KSB7XHJcbiAgICAvLyBDcmVhdGVzIHNlYXJjaCBwYXJhbXMgb2JqZWN0IGNvbXBsaWFudCB3aXRoIE1laWxpc2VhcmNoXHJcbiAgICB2YXIgbWVpbGlTZWFyY2hQYXJhbXMgPSB7fTtcclxuICAgIC8vIEZhY2V0c1xyXG4gICAgdmFyIGZhY2V0cyA9IHNlYXJjaENvbnRleHQgPT09IG51bGwgfHwgc2VhcmNoQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VhcmNoQ29udGV4dC5mYWNldHM7XHJcbiAgICBpZiAoZmFjZXRzID09PSBudWxsIHx8IGZhY2V0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFjZXRzLmxlbmd0aCkge1xyXG4gICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmZhY2V0c0Rpc3RyaWJ1dGlvbiA9IGZhY2V0cztcclxuICAgIH1cclxuICAgIC8vIEF0dHJpYnV0ZXMgVG8gQ3JvcFxyXG4gICAgdmFyIGF0dHJpYnV0ZXNUb0Nyb3AgPSBzZWFyY2hDb250ZXh0ID09PSBudWxsIHx8IHNlYXJjaENvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlYXJjaENvbnRleHQuYXR0cmlidXRlc1RvU25pcHBldDtcclxuICAgIGlmIChhdHRyaWJ1dGVzVG9Dcm9wKSB7XHJcbiAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuYXR0cmlidXRlc1RvQ3JvcCA9IGF0dHJpYnV0ZXNUb0Nyb3A7XHJcbiAgICB9XHJcbiAgICAvLyBBdHRyaWJ1dGVzIFRvIENyb3AgbWFya2VyXHJcbiAgICB2YXIgY3JvcE1hcmtlciA9IHNlYXJjaENvbnRleHQgPT09IG51bGwgfHwgc2VhcmNoQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VhcmNoQ29udGV4dC5zbmlwcGV0RWxsaXBzaXNUZXh0O1xyXG4gICAgaWYgKGNyb3BNYXJrZXIgIT0gbnVsbCkge1xyXG4gICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmNyb3BNYXJrZXIgPSBjcm9wTWFya2VyO1xyXG4gICAgfVxyXG4gICAgLy8gQXR0cmlidXRlcyBUbyBSZXRyaWV2ZVxyXG4gICAgdmFyIGF0dHJpYnV0ZXNUb1JldHJpZXZlID0gc2VhcmNoQ29udGV4dCA9PT0gbnVsbCB8fCBzZWFyY2hDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hDb250ZXh0LmF0dHJpYnV0ZXNUb1JldHJpZXZlO1xyXG4gICAgaWYgKGF0dHJpYnV0ZXNUb1JldHJpZXZlKSB7XHJcbiAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuYXR0cmlidXRlc1RvUmV0cmlldmUgPSBhdHRyaWJ1dGVzVG9SZXRyaWV2ZTtcclxuICAgIH1cclxuICAgIC8vIEZpbHRlclxyXG4gICAgdmFyIGZpbHRlciA9IGFkYXB0RmlsdGVycyhzZWFyY2hDb250ZXh0ID09PSBudWxsIHx8IHNlYXJjaENvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlYXJjaENvbnRleHQuZmlsdGVycywgc2VhcmNoQ29udGV4dCA9PT0gbnVsbCB8fCBzZWFyY2hDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hDb250ZXh0Lm51bWVyaWNGaWx0ZXJzLCBzZWFyY2hDb250ZXh0ID09PSBudWxsIHx8IHNlYXJjaENvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlYXJjaENvbnRleHQuZmFjZXRGaWx0ZXJzKTtcclxuICAgIGlmIChmaWx0ZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuZmlsdGVyID0gZmlsdGVyO1xyXG4gICAgfVxyXG4gICAgLy8gQXR0cmlidXRlcyBUbyBSZXRyaWV2ZVxyXG4gICAgaWYgKGF0dHJpYnV0ZXNUb1JldHJpZXZlKSB7XHJcbiAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuYXR0cmlidXRlc1RvQ3JvcCA9IGF0dHJpYnV0ZXNUb1JldHJpZXZlO1xyXG4gICAgfVxyXG4gICAgLy8gQXR0cmlidXRlcyBUbyBIaWdobGlnaHRcclxuICAgIG1laWxpU2VhcmNoUGFyYW1zLmF0dHJpYnV0ZXNUb0hpZ2hsaWdodCA9IChzZWFyY2hDb250ZXh0ID09PSBudWxsIHx8IHNlYXJjaENvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlYXJjaENvbnRleHQuYXR0cmlidXRlc1RvSGlnaGxpZ2h0KSB8fCBbXHJcbiAgICAgICAgJyonLFxyXG4gICAgXTtcclxuICAgIC8vIEhpZ2hsaWdodCBwcmUgdGFnXHJcbiAgICB2YXIgaGlnaGxpZ2h0UHJlVGFnID0gc2VhcmNoQ29udGV4dCA9PT0gbnVsbCB8fCBzZWFyY2hDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hDb250ZXh0LmhpZ2hsaWdodFByZVRhZztcclxuICAgIGlmIChoaWdobGlnaHRQcmVUYWcpIHtcclxuICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5oaWdobGlnaHRQcmVUYWcgPSBoaWdobGlnaHRQcmVUYWc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5oaWdobGlnaHRQcmVUYWcgPSAnX19haXMtaGlnaGxpZ2h0X18nO1xyXG4gICAgfVxyXG4gICAgLy8gSGlnaGxpZ2h0IHBvc3QgdGFnXHJcbiAgICB2YXIgaGlnaGxpZ2h0UG9zdFRhZyA9IHNlYXJjaENvbnRleHQgPT09IG51bGwgfHwgc2VhcmNoQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VhcmNoQ29udGV4dC5oaWdobGlnaHRQb3N0VGFnO1xyXG4gICAgaWYgKGhpZ2hsaWdodFBvc3RUYWcpIHtcclxuICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5oaWdobGlnaHRQb3N0VGFnID0gaGlnaGxpZ2h0UG9zdFRhZztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmhpZ2hsaWdodFBvc3RUYWcgPSAnX18vYWlzLWhpZ2hsaWdodF9fJztcclxuICAgIH1cclxuICAgIHZhciBwbGFjZWhvbGRlclNlYXJjaCA9IHNlYXJjaENvbnRleHQucGxhY2Vob2xkZXJTZWFyY2g7XHJcbiAgICB2YXIgcXVlcnkgPSBzZWFyY2hDb250ZXh0LnF1ZXJ5O1xyXG4gICAgLy8gUGFnaW5hdGlvblxyXG4gICAgdmFyIHBhZ2luYXRpb24gPSBzZWFyY2hDb250ZXh0LnBhZ2luYXRpb247XHJcbiAgICAvLyBMaW1pdCBiYXNlZCBvbiBwYWdpbmF0aW9uIHByZWZlcmVuY2VzXHJcbiAgICBpZiAoKCFwbGFjZWhvbGRlclNlYXJjaCAmJiBxdWVyeSA9PT0gJycpIHx8XHJcbiAgICAgICAgcGFnaW5hdGlvbi5wYWdpbmF0aW9uVG90YWxIaXRzID09PSAwKSB7XHJcbiAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMubGltaXQgPSAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2VhcmNoQ29udGV4dC5maW5pdGVQYWdpbmF0aW9uKSB7XHJcbiAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMubGltaXQgPSBwYWdpbmF0aW9uLnBhZ2luYXRpb25Ub3RhbEhpdHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgbGltaXQgPSAocGFnaW5hdGlvbi5wYWdlICsgMSkgKiBwYWdpbmF0aW9uLmhpdHNQZXJQYWdlICsgMTtcclxuICAgICAgICAvLyBJZiB0aGUgbGltaXQgaXMgYmlnZ2VyIHRoYW4gdGhlIHRvdGFsIGhpdHMgYWNjZXB0ZWRcclxuICAgICAgICAvLyBmb3JjZSB0aGUgbGltaXQgdG8gdGhhdCBhbW91bnRcclxuICAgICAgICBpZiAobGltaXQgPiBwYWdpbmF0aW9uLnBhZ2luYXRpb25Ub3RhbEhpdHMpIHtcclxuICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMubGltaXQgPSBwYWdpbmF0aW9uLnBhZ2luYXRpb25Ub3RhbEhpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5saW1pdCA9IGxpbWl0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBzb3J0ID0gc2VhcmNoQ29udGV4dC5zb3J0O1xyXG4gICAgLy8gU29ydFxyXG4gICAgaWYgKHNvcnQgPT09IG51bGwgfHwgc29ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc29ydC5sZW5ndGgpIHtcclxuICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5zb3J0ID0gW3NvcnRdO1xyXG4gICAgfVxyXG4gICAgdmFyIGdlb1NlYXJjaENvbnRleHQgPSBjcmVhdGVHZW9TZWFyY2hDb250ZXh0KHNlYXJjaENvbnRleHQpO1xyXG4gICAgdmFyIGdlb1J1bGVzID0gYWRhcHRHZW9Qb2ludHNSdWxlcyhnZW9TZWFyY2hDb250ZXh0KTtcclxuICAgIGlmIChnZW9SdWxlcyA9PT0gbnVsbCB8fCBnZW9SdWxlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VvUnVsZXMuZmlsdGVyKSB7XHJcbiAgICAgICAgaWYgKG1laWxpU2VhcmNoUGFyYW1zLmZpbHRlcikge1xyXG4gICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5maWx0ZXIudW5zaGlmdChnZW9SdWxlcy5maWx0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuZmlsdGVyID0gW2dlb1J1bGVzLmZpbHRlcl07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1laWxpU2VhcmNoUGFyYW1zO1xyXG59XG5cbi8qKlxyXG4gKiBTbGljZSB0aGUgcmVxdWVzdGVkIGhpdHMgYmFzZWQgb24gdGhlIHBhZ2luYXRpb24gcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSAge1JlY29yZDxzdHJpbmd9IGhpdHNcclxuICogQHBhcmFtICB7bnVtYmVyfSBwYWdlXHJcbiAqIEBwYXJhbSAge251bWJlcn0gaGl0c1BlclBhZ2VcclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gYWRhcHRQYWdpbmF0aW9uKGhpdHMsIHBhZ2UsIGhpdHNQZXJQYWdlKSB7XHJcbiAgICBpZiAoaGl0c1BlclBhZ2UgPCAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgdG9vIHNtYWxsIGZvciBcImhpdHNQZXJQYWdlXCIgcGFyYW1ldGVyLCBleHBlY3RlZCBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgOTIyMzM3MjAzNjg1NDc3NTgwNycpO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0YXJ0ID0gcGFnZSAqIGhpdHNQZXJQYWdlO1xyXG4gICAgcmV0dXJuIGhpdHMuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgaGl0c1BlclBhZ2UpO1xyXG59XG5cbi8qKlxyXG4gKiBTdHJpbmdpZnkgdmFsdWVzIGZvbGxvd2luZyBpbnN0YW50c2VhcmNoIHByYWN0aWNlcy5cclxuICpcclxuICogQHBhcmFtICB7YW55fSB2YWx1ZSAtIHZhbHVlIHRoYXQgbmVlZHMgdG8gYmUgc3RyaW5naWZpZWRcclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVZhbHVlKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIFN0cmluZ1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyB1bmRlZmluZWRcclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobnVsbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWN1cnNpZiBmdW5jdGlvbiB3cmFwIHRoZSBkZWVwZXN0IHBvc3NpYmxlIHZhbHVlXHJcbiAqIHRoZSBmb2xsb3dpbmcgd2F5OiB7IHZhbHVlOiBcInh4XCIgfS5cclxuICpcclxuICogRm9yIGV4YW1wbGU6XHJcbiAqXHJcbiAqIHtcclxuICogXCJyb290RmllbGRcIjogeyBcInZhbHVlXCI6IFwieFwiIH1cclxuICogXCJuZXN0ZWRGaWVsZFwiOiB7IGNoaWxkOiB7IHZhbHVlOiBcInlcIiB9IH1cclxuICogfVxyXG4gKlxyXG4gKiByZWN1cnNpdml0eSBjb250aW51ZXMgdW50aWwgdGhlIHZhbHVlIGlzIG5vdCBhbiBhcnJheSBvciBhbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSAge2FueX0gdmFsdWUgLSB2YWx1ZSBvZiBhIGZpZWxkXHJcbiAqXHJcbiAqIEByZXR1cm5zIFJlY29yZDxzdHJpbmcsIGFueT5cclxuICovXHJcbmZ1bmN0aW9uIHdyYXBWYWx1ZSh2YWx1ZSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgLy8gQXJyYXlcclxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB3cmFwVmFsdWUoZWxlbSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQdXJlT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIC8vIE9iamVjdFxyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkucmVkdWNlKGZ1bmN0aW9uIChuZXN0ZWQsIGtleSkge1xyXG4gICAgICAgICAgICBuZXN0ZWRba2V5XSA9IHdyYXBWYWx1ZSh2YWx1ZVtrZXldKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5lc3RlZDtcclxuICAgICAgICB9LCB7fSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4geyB2YWx1ZTogc3RyaW5naWZ5VmFsdWUodmFsdWUpIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFkYXB0IE1laWxpc2VhcmNoIGZvcm1hdHRlZCBmaWVsZHMgdG8gYSBmb3JtYXQgY29tcGxpYW50IHRvIGluc3RhbnRzZWFyY2guanMuXHJcbiAqXHJcbiAqIEBwYXJhbSAge1JlY29yZDxzdHJpbmd9IGZvcm1hdHRlZEhpdFxyXG4gKiBAcGFyYW0gIHtTZWFyY2hDb250ZXh0fSBzZWFyY2hDb250ZXh0XHJcbiAqIEByZXR1cm5zIHtSZWNvcmR9XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGFwdEZvcm1hdHRlZEZpZWxkcyhoaXQpIHtcclxuICAgIGlmICghaGl0KVxyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIHZhciBfZm9ybWF0dGVkUmVzdWx0ID0gd3JhcFZhbHVlKGhpdCk7XHJcbiAgICB2YXIgaGlnaGxpZ2h0ZWRIaXQgPSB7XHJcbiAgICAgICAgLy8gV2UgY291bGQgbm90IGRldGVybWluZSB3aGF0IHRoZSBkaWZmZXJlbmNlcyBhcmUgYmV0d2VlbiB0aG9zZSB0d28gZmllbGRzLlxyXG4gICAgICAgIF9oaWdobGlnaHRSZXN1bHQ6IF9mb3JtYXR0ZWRSZXN1bHQsXHJcbiAgICAgICAgX3NuaXBwZXRSZXN1bHQ6IF9mb3JtYXR0ZWRSZXN1bHRcclxuICAgIH07XHJcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWRIaXQ7XHJcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSAge2FueVtdfSBoaXRzXHJcbiAqIEByZXR1cm5zIHtBcnJheTxSZWNvcmQ8c3RyaW5nLCBhbnk+Pn1cclxuICovXHJcbmZ1bmN0aW9uIGFkYXB0R2VvUmVzcG9uc2UoaGl0cykge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGhpdHNbaV0uX2dlbykge1xyXG4gICAgICAgICAgICBoaXRzW2ldLl9nZW9sb2MgPSB7XHJcbiAgICAgICAgICAgICAgICBsYXQ6IGhpdHNbaV0uX2dlby5sYXQsXHJcbiAgICAgICAgICAgICAgICBsbmc6IGhpdHNbaV0uX2dlby5sbmdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaGl0c1tpXS5vYmplY3RJRCA9IFwiXCIuY29uY2F0KGkgKyBNYXRoLnJhbmRvbSgpICogMTAwMDAwMCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBoaXRzW2ldLl9nZW87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhpdHM7XHJcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSAge0FycmF5PFJlY29yZDxzdHJpbmd9IGhpdHNcclxuICogQHBhcmFtICB7U2VhcmNoQ29udGV4dH0gc2VhcmNoQ29udGV4dFxyXG4gKiBAcGFyYW0gIHtQYWdpbmF0aW9uQ29udGV4dH0gcGFnaW5hdGlvbkNvbnRleHRcclxuICogQHJldHVybnMge2FueX1cclxuICovXHJcbmZ1bmN0aW9uIGFkYXB0SGl0cyhoaXRzLCBzZWFyY2hDb250ZXh0LCBwYWdpbmF0aW9uQ29udGV4dCkge1xyXG4gICAgdmFyIHByaW1hcnlLZXkgPSBzZWFyY2hDb250ZXh0LnByaW1hcnlLZXk7XHJcbiAgICB2YXIgaGl0c1BlclBhZ2UgPSBwYWdpbmF0aW9uQ29udGV4dC5oaXRzUGVyUGFnZSwgcGFnZSA9IHBhZ2luYXRpb25Db250ZXh0LnBhZ2U7XHJcbiAgICB2YXIgcGFnaW5hdGVkSGl0cyA9IGFkYXB0UGFnaW5hdGlvbihoaXRzLCBwYWdlLCBoaXRzUGVyUGFnZSk7XHJcbiAgICB2YXIgYWRhcHRlZEhpdHMgPSBwYWdpbmF0ZWRIaXRzLm1hcChmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlcyBIaXQgb2JqZWN0IGNvbXBsaWFudCB3aXRoIEluc3RhbnRTZWFyY2hcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoaGl0KS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRIaXQgPSBoaXQuX2Zvcm1hdHRlZDsgaGl0Ll9tYXRjaGVzSW5mbzsgdmFyIGRvY3VtZW50RmllbGRzID0gX19yZXN0KGhpdCwgW1wiX2Zvcm1hdHRlZFwiLCBcIl9tYXRjaGVzSW5mb1wiXSk7XHJcbiAgICAgICAgICAgIHZhciBhZGFwdGVkSGl0ID0gT2JqZWN0LmFzc2lnbihkb2N1bWVudEZpZWxkcywgYWRhcHRGb3JtYXR0ZWRGaWVsZHMoZm9ybWF0dGVkSGl0KSk7XHJcbiAgICAgICAgICAgIGlmIChwcmltYXJ5S2V5KSB7XHJcbiAgICAgICAgICAgICAgICBhZGFwdGVkSGl0Lm9iamVjdElEID0gaGl0W3ByaW1hcnlLZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVkSGl0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGl0O1xyXG4gICAgfSk7XHJcbiAgICBhZGFwdGVkSGl0cyA9IGFkYXB0R2VvUmVzcG9uc2UoYWRhcHRlZEhpdHMpO1xyXG4gICAgcmV0dXJuIGFkYXB0ZWRIaXRzO1xyXG59XG5cbi8qKlxyXG4gKiBBZGFwdCBzZWFyY2ggcmVzcG9uc2UgZnJvbSBNZWlsaXNlYXJjaFxyXG4gKiB0byBzZWFyY2ggcmVzcG9uc2UgY29tcGxpYW50IHdpdGggaW5zdGFudHNlYXJjaC5qc1xyXG4gKlxyXG4gKiBAcGFyYW0gIHtNZWlsaVNlYXJjaFJlc3BvbnNlPFJlY29yZDxzdHJpbmd9IHNlYXJjaFJlc3BvbnNlXHJcbiAqIEBwYXJhbSAge1NlYXJjaENvbnRleHR9IHNlYXJjaENvbnRleHRcclxuICogQHBhcmFtICB7UGFnaW5hdGlvbkNvbnRleHR9IHBhZ2luYXRpb25Db250ZXh0XHJcbiAqIEByZXR1cm5zIHt7IHJlc3VsdHM6IEFycmF5PEFsZ29saWFTZWFyY2hSZXNwb25zZTxUPj4gfX1cclxuICovXHJcbmZ1bmN0aW9uIGFkYXB0U2VhcmNoUmVzcG9uc2Uoc2VhcmNoUmVzcG9uc2UsIHNlYXJjaENvbnRleHQpIHtcclxuICAgIHZhciBzZWFyY2hSZXNwb25zZU9wdGlvbmFscyA9IHt9O1xyXG4gICAgdmFyIGZhY2V0cyA9IHNlYXJjaFJlc3BvbnNlLmZhY2V0c0Rpc3RyaWJ1dGlvbjtcclxuICAgIHZhciBwYWdpbmF0aW9uID0gc2VhcmNoQ29udGV4dC5wYWdpbmF0aW9uO1xyXG4gICAgdmFyIGV4aGF1c3RpdmVGYWNldHNDb3VudCA9IHNlYXJjaFJlc3BvbnNlID09PSBudWxsIHx8IHNlYXJjaFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hSZXNwb25zZS5leGhhdXN0aXZlRmFjZXRzQ291bnQ7XHJcbiAgICBpZiAoZXhoYXVzdGl2ZUZhY2V0c0NvdW50KSB7XHJcbiAgICAgICAgc2VhcmNoUmVzcG9uc2VPcHRpb25hbHMuZXhoYXVzdGl2ZUZhY2V0c0NvdW50ID0gZXhoYXVzdGl2ZUZhY2V0c0NvdW50O1xyXG4gICAgfVxyXG4gICAgdmFyIG5iUGFnZXMgPSBjZWlsZWREaXZpc2lvbihzZWFyY2hSZXNwb25zZS5oaXRzLmxlbmd0aCwgcGFnaW5hdGlvbi5oaXRzUGVyUGFnZSk7XHJcbiAgICB2YXIgaGl0cyA9IGFkYXB0SGl0cyhzZWFyY2hSZXNwb25zZS5oaXRzLCBzZWFyY2hDb250ZXh0LCBwYWdpbmF0aW9uKTtcclxuICAgIHZhciBleGhhdXN0aXZlTmJIaXRzID0gc2VhcmNoUmVzcG9uc2UuZXhoYXVzdGl2ZU5iSGl0cztcclxuICAgIHZhciBuYkhpdHMgPSBzZWFyY2hSZXNwb25zZS5uYkhpdHM7XHJcbiAgICB2YXIgcHJvY2Vzc2luZ1RpbWVNcyA9IHNlYXJjaFJlc3BvbnNlLnByb2Nlc3NpbmdUaW1lTXM7XHJcbiAgICB2YXIgcXVlcnkgPSBzZWFyY2hSZXNwb25zZS5xdWVyeTtcclxuICAgIHZhciBoaXRzUGVyUGFnZSA9IHBhZ2luYXRpb24uaGl0c1BlclBhZ2UsIHBhZ2UgPSBwYWdpbmF0aW9uLnBhZ2U7XHJcbiAgICAvLyBDcmVhdGUgcmVzcG9uc2Ugb2JqZWN0IGNvbXBsaWFudCB3aXRoIEluc3RhbnRTZWFyY2hcclxuICAgIHZhciBhZGFwdGVkU2VhcmNoUmVzcG9uc2UgPSBfX2Fzc2lnbih7IGluZGV4OiBzZWFyY2hDb250ZXh0LmluZGV4VWlkLCBoaXRzUGVyUGFnZTogaGl0c1BlclBhZ2UsIHBhZ2U6IHBhZ2UsIGZhY2V0czogZmFjZXRzLCBuYlBhZ2VzOiBuYlBhZ2VzLCBleGhhdXN0aXZlTmJIaXRzOiBleGhhdXN0aXZlTmJIaXRzLCBuYkhpdHM6IG5iSGl0cywgcHJvY2Vzc2luZ1RpbWVNUzogcHJvY2Vzc2luZ1RpbWVNcywgcXVlcnk6IHF1ZXJ5LCBoaXRzOiBoaXRzLCBwYXJhbXM6ICcnIH0sIHNlYXJjaFJlc3BvbnNlT3B0aW9uYWxzKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdWx0czogW2FkYXB0ZWRTZWFyY2hSZXNwb25zZV1cclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSAge0FsZ29saWFNdWx0aXBsZVF1ZXJpZXNRdWVyeX0gc2VhcmNoUmVxdWVzdFxyXG4gKiBAcGFyYW0gIHtDb250ZXh0fSBvcHRpb25zXHJcbiAqIEByZXR1cm5zIHtTZWFyY2hDb250ZXh0fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUGFnaW5hdGlvbkNvbnRleHQoX2EpIHtcclxuICAgIHZhciBwYWdpbmF0aW9uVG90YWxIaXRzID0gX2EucGFnaW5hdGlvblRvdGFsSGl0cywgaGl0c1BlclBhZ2UgPSBfYS5oaXRzUGVyUGFnZSwgcGFnZSA9IF9hLnBhZ2U7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBhZ2luYXRpb25Ub3RhbEhpdHM6IHBhZ2luYXRpb25Ub3RhbEhpdHMgIT0gbnVsbCA/IHBhZ2luYXRpb25Ub3RhbEhpdHMgOiAyMDAsXHJcbiAgICAgICAgaGl0c1BlclBhZ2U6IGhpdHNQZXJQYWdlID09PSB1bmRlZmluZWQgPyAyMCA6IGhpdHNQZXJQYWdlLFxyXG4gICAgICAgIHBhZ2U6IHBhZ2UgfHwgMFxyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogQHBhcmFtICB7QWxnb2xpYU11bHRpcGxlUXVlcmllc1F1ZXJ5fSBzZWFyY2hSZXF1ZXN0XHJcbiAqIEBwYXJhbSAge0NvbnRleHR9IG9wdGlvbnNcclxuICogQHJldHVybnMge1NlYXJjaENvbnRleHR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hDb250ZXh0KHNlYXJjaFJlcXVlc3QsIG9wdGlvbnMsIGRlZmF1bHRGYWNldERpc3RyaWJ1dGlvbikge1xyXG4gICAgLy8gU3BsaXQgaW5kZXggbmFtZSBhbmQgcG9zc2libGUgc29ydGluZyBydWxlc1xyXG4gICAgdmFyIF9hID0gc2VhcmNoUmVxdWVzdC5pbmRleE5hbWUuc3BsaXQoJzonKSwgaW5kZXhVaWQgPSBfYVswXSwgc29ydEJ5QXJyYXkgPSBfYS5zbGljZSgxKTtcclxuICAgIHZhciBpbnN0YW50U2VhcmNoUGFyYW1zID0gc2VhcmNoUmVxdWVzdC5wYXJhbXM7XHJcbiAgICB2YXIgcGFnaW5hdGlvbiA9IGNyZWF0ZVBhZ2luYXRpb25Db250ZXh0KHtcclxuICAgICAgICBwYWdpbmF0aW9uVG90YWxIaXRzOiBvcHRpb25zLnBhZ2luYXRpb25Ub3RhbEhpdHMsXHJcbiAgICAgICAgaGl0c1BlclBhZ2U6IGluc3RhbnRTZWFyY2hQYXJhbXMgPT09IG51bGwgfHwgaW5zdGFudFNlYXJjaFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFudFNlYXJjaFBhcmFtcy5oaXRzUGVyUGFnZSxcclxuICAgICAgICBwYWdlOiBpbnN0YW50U2VhcmNoUGFyYW1zID09PSBudWxsIHx8IGluc3RhbnRTZWFyY2hQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbnRTZWFyY2hQYXJhbXMucGFnZVxyXG4gICAgfSk7XHJcbiAgICB2YXIgc2VhcmNoQ29udGV4dCA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgaW5zdGFudFNlYXJjaFBhcmFtcyksIHsgc29ydDogc29ydEJ5QXJyYXkuam9pbignOicpIHx8ICcnLCBpbmRleFVpZDogaW5kZXhVaWQsIHBhZ2luYXRpb246IHBhZ2luYXRpb24sIGRlZmF1bHRGYWNldERpc3RyaWJ1dGlvbjogZGVmYXVsdEZhY2V0RGlzdHJpYnV0aW9uLCBwbGFjZWhvbGRlclNlYXJjaDogb3B0aW9ucy5wbGFjZWhvbGRlclNlYXJjaCAhPT0gZmFsc2UsIGtlZXBaZXJvRmFjZXRzOiAhIW9wdGlvbnMua2VlcFplcm9GYWNldHMsIGZpbml0ZVBhZ2luYXRpb246ICEhb3B0aW9ucy5maW5pdGVQYWdpbmF0aW9uIH0pO1xyXG4gICAgcmV0dXJuIHNlYXJjaENvbnRleHQ7XHJcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSAge1JlY29yZDxzdHJpbmd9IGNhY2hlXHJcbiAqIEByZXR1cm5zIHtTZWFyY2hDYWNoZX1cclxuICovXHJcbmZ1bmN0aW9uIFNlYXJjaENhY2hlKGNhY2hlKSB7XHJcbiAgICBpZiAoY2FjaGUgPT09IHZvaWQgMCkgeyBjYWNoZSA9IHt9OyB9XHJcbiAgICB2YXIgc2VhcmNoQ2FjaGUgPSBjYWNoZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0RW50cnk6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKHNlYXJjaENhY2hlW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc2VhcmNoQ2FjaGVba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWFyY2hDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb3JtYXRLZXk6IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnlBcnJheShjb21wb25lbnRzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEVudHJ5OiBmdW5jdGlvbiAoa2V5LCBzZWFyY2hSZXNwb25zZSkge1xyXG4gICAgICAgICAgICBzZWFyY2hDYWNoZVtrZXldID0gSlNPTi5zdHJpbmdpZnkoc2VhcmNoUmVzcG9uc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gY2FjaGVGaXJzdEZhY2V0c0Rpc3RyaWJ1dGlvbihkZWZhdWx0RmFjZXREaXN0cmlidXRpb24sIHNlYXJjaFJlc3BvbnNlKSB7XHJcbiAgICBpZiAoc2VhcmNoUmVzcG9uc2UucXVlcnkgPT09ICcnICYmXHJcbiAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdEZhY2V0RGlzdHJpYnV0aW9uKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gc2VhcmNoUmVzcG9uc2UuZmFjZXRzRGlzdHJpYnV0aW9uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlZmF1bHRGYWNldERpc3RyaWJ1dGlvbjtcclxufVxuXG4vKipcclxuICogSW5zdGFuY2lhdGUgU2VhcmNoQ2xpZW50IHJlcXVpcmVkIGJ5IGluc3RhbnRzZWFyY2guanMuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gaG9zdFVybFxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGFwaUtleVxyXG4gKiBAcGFyYW0gIHtJbnN0YW50TWVpbGlTZWFyY2hPcHRpb25zPXt9fSBtZWlsaVNlYXJjaE9wdGlvbnNcclxuICogQHJldHVybnMge0luc3RhbnRNZWlsaVNlYXJjaEluc3RhbmNlfVxyXG4gKi9cclxuZnVuY3Rpb24gaW5zdGFudE1laWxpU2VhcmNoKGhvc3RVcmwsIGFwaUtleSwgaW5zdGFudE1laWxpU2VhcmNoT3B0aW9ucykge1xyXG4gICAgaWYgKGFwaUtleSA9PT0gdm9pZCAwKSB7IGFwaUtleSA9ICcnOyB9XHJcbiAgICBpZiAoaW5zdGFudE1laWxpU2VhcmNoT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGluc3RhbnRNZWlsaVNlYXJjaE9wdGlvbnMgPSB7fTsgfVxyXG4gICAgLy8gY3JlYXRlIHNlYXJjaCByZXNvbHZlciB3aXRoIGluY2x1ZGVkIGNhY2hlXHJcbiAgICB2YXIgc2VhcmNoUmVzb2x2ZXIgPSBTZWFyY2hSZXNvbHZlcihTZWFyY2hDYWNoZSgpKTtcclxuICAgIC8vIHBhZ2luYXRpb25Ub3RhbEhpdHMgY2FuIGJlIDAgYXMgaXQgaXMgYSB2YWxpZCBudW1iZXJcclxuICAgIHZhciBkZWZhdWx0RmFjZXREaXN0cmlidXRpb24gPSB7fTtcclxuICAgIHZhciBtZWlsaXNlYXJjaENsaWVudCA9IG5ldyBNZWlsaVNlYXJjaCh7IGhvc3Q6IGhvc3RVcmwsIGFwaUtleTogYXBpS2V5IH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gIHtyZWFkb25seUFsZ29saWFNdWx0aXBsZVF1ZXJpZXNRdWVyeVtdfSBpbnN0YW50U2VhcmNoUmVxdWVzdHNcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2VhcmNoOiBmdW5jdGlvbiAoaW5zdGFudFNlYXJjaFJlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWFyY2hSZXF1ZXN0LCBzZWFyY2hDb250ZXh0LCBhZGFwdGVkU2VhcmNoUmVxdWVzdCwgc2VhcmNoUmVzcG9uc2UsIGFkYXB0ZWRTZWFyY2hSZXNwb25zZSwgZV8xO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFJlcXVlc3QgPSBpbnN0YW50U2VhcmNoUmVxdWVzdHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hDb250ZXh0ID0gY3JlYXRlU2VhcmNoQ29udGV4dChzZWFyY2hSZXF1ZXN0LCBpbnN0YW50TWVpbGlTZWFyY2hPcHRpb25zLCBkZWZhdWx0RmFjZXREaXN0cmlidXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRhcHRlZFNlYXJjaFJlcXVlc3QgPSBhZGFwdFNlYXJjaFBhcmFtcyhzZWFyY2hDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNlYXJjaFJlc29sdmVyLnNlYXJjaFJlc3BvbnNlKHNlYXJjaENvbnRleHQsIGFkYXB0ZWRTZWFyY2hSZXF1ZXN0LCBtZWlsaXNlYXJjaENsaWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSBmaXJzdCBmYWNldHMgZGlzdHJpYnV0aW9uIG9mIHRoZSBpbnN0YW50TWVpbGlzZWFyY2ggaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkZWQgdG8gYWRkIGluIHRoZSBmYWNldHNEaXN0cmlidXRpb24gdGhlIGZpZWxkcyB0aGF0IHdlcmUgbm90IHJldHVybmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgdXNlciBzZXRzIGBrZWVwWmVyb0ZhY2V0c2AgdG8gdHJ1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFJlc3BvbnNlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgZmlyc3QgZmFjZXRzIGRpc3RyaWJ1dGlvbiBvZiB0aGUgaW5zdGFudE1laWxpc2VhcmNoIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkZWQgdG8gYWRkIGluIHRoZSBmYWNldHNEaXN0cmlidXRpb24gdGhlIGZpZWxkcyB0aGF0IHdlcmUgbm90IHJldHVybmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSB1c2VyIHNldHMgYGtlZXBaZXJvRmFjZXRzYCB0byB0cnVlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEZhY2V0RGlzdHJpYnV0aW9uID0gY2FjaGVGaXJzdEZhY2V0c0Rpc3RyaWJ1dGlvbihkZWZhdWx0RmFjZXREaXN0cmlidXRpb24sIHNlYXJjaFJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkYXB0ZWRTZWFyY2hSZXNwb25zZSA9IGFkYXB0U2VhcmNoUmVzcG9uc2Uoc2VhcmNoUmVzcG9uc2UsIHNlYXJjaENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGFkYXB0ZWRTZWFyY2hSZXNwb25zZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZV8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZWFyY2hGb3JGYWNldFZhbHVlczogZnVuY3Rpb24gKF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignU2VhcmNoRm9yRmFjZXRWYWx1ZXMgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBNZWlsaXNlYXJjaCcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTsgLy8gYWRkZWQgaGVyZSB0byBhdm9pZCBjb21waWxhdGlvbiBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmV4cG9ydCB7IGluc3RhbnRNZWlsaVNlYXJjaCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.esm.js\n");

/***/ })

};
;