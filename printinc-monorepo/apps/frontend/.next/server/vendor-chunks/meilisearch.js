"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/meilisearch";
exports.ids = ["vendor-chunks/meilisearch"];
exports.modules = {

/***/ "(ssr)/./node_modules/meilisearch/dist/bundles/meilisearch.cjs.js":
/*!******************************************************************!*\
  !*** ./node_modules/meilisearch/dist/bundles/meilisearch.cjs.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n__webpack_require__(/*! cross-fetch/polyfill */ \"(ssr)/./node_modules/cross-fetch/dist/node-polyfill.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar MeiliSearchCommunicationError = /** @class */ (function (_super) {\r\n    __extends(MeiliSearchCommunicationError, _super);\r\n    function MeiliSearchCommunicationError(message, body, url, stack) {\r\n        var _this = this;\r\n        var _a, _b, _c;\r\n        _this = _super.call(this, message) || this;\r\n        _this.name = 'MeiliSearchCommunicationError';\r\n        _this.type = 'MeiliSearchCommunicationError';\r\n        if (body instanceof Response) {\r\n            _this.message = body.statusText;\r\n            _this.statusCode = body.status;\r\n        }\r\n        if (body instanceof Error) {\r\n            _this.errno = body.errno;\r\n            _this.code = body.code;\r\n        }\r\n        if (stack) {\r\n            _this.stack = stack;\r\n            _this.stack = (_a = _this.stack) === null || _a === void 0 ? void 0 : _a.replace(/(TypeError|FetchError)/, _this.name);\r\n            _this.stack = (_b = _this.stack) === null || _b === void 0 ? void 0 : _b.replace('Failed to fetch', \"request to \".concat(url, \" failed, reason: connect ECONNREFUSED\"));\r\n            _this.stack = (_c = _this.stack) === null || _c === void 0 ? void 0 : _c.replace('Not Found', \"Not Found: \".concat(url));\r\n        }\r\n        else {\r\n            if (Error.captureStackTrace) {\r\n                Error.captureStackTrace(_this, MeiliSearchCommunicationError);\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    return MeiliSearchCommunicationError;\r\n}(Error));\n\nvar MeiliSearchApiError = /** @class */ (function (_super) {\r\n    __extends(class_1, _super);\r\n    function class_1(error, status) {\r\n        var _this = _super.call(this, error.message) || this;\r\n        _this.name = 'MeiliSearchApiError';\r\n        _this.code = error.code;\r\n        _this.type = error.type;\r\n        _this.link = error.link;\r\n        _this.message = error.message;\r\n        _this.httpStatus = status;\r\n        // Make errors comparison possible. ex: error instanceof MeiliSearchApiError.\r\n        Object.setPrototypeOf(_this, MeiliSearchApiError.prototype);\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(_this, MeiliSearchApiError);\r\n        }\r\n        return _this;\r\n    }\r\n    return class_1;\r\n}(Error));\n\nfunction httpResponseErrorHandler(response) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var err;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!!response.ok) return [3 /*break*/, 5];\r\n                    err = void 0;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, 3, , 4]);\r\n                    return [4 /*yield*/, response.json()];\r\n                case 2:\r\n                    err = _a.sent();\r\n                    return [3 /*break*/, 4];\r\n                case 3:\r\n                    _a.sent();\r\n                    throw new MeiliSearchCommunicationError(response.statusText, response, response.url);\r\n                case 4: throw new MeiliSearchApiError(err, response.status);\r\n                case 5: return [2 /*return*/, response];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction httpErrorHandler(response, stack, url) {\r\n    if (response.type !== 'MeiliSearchApiError') {\r\n        throw new MeiliSearchCommunicationError(response.message, response, url, stack);\r\n    }\r\n    throw response;\r\n}\n\nvar MeiliSearchError = /** @class */ (function (_super) {\r\n    __extends(MeiliSearchError, _super);\r\n    function MeiliSearchError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.name = 'MeiliSearchError';\r\n        _this.type = 'MeiliSearchError';\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(_this, MeiliSearchError);\r\n        }\r\n        return _this;\r\n    }\r\n    return MeiliSearchError;\r\n}(Error));\n\nvar MeiliSearchTimeOutError = /** @class */ (function (_super) {\r\n    __extends(MeiliSearchTimeOutError, _super);\r\n    function MeiliSearchTimeOutError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.name = 'MeiliSearchTimeOutError';\r\n        _this.type = _this.constructor.name;\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(_this, MeiliSearchTimeOutError);\r\n        }\r\n        return _this;\r\n    }\r\n    return MeiliSearchTimeOutError;\r\n}(Error));\n\n/**\r\n * Removes undefined entries from object\r\n */\r\nfunction removeUndefinedFromObject(obj) {\r\n    return Object.entries(obj).reduce(function (acc, curEntry) {\r\n        var key = curEntry[0], val = curEntry[1];\r\n        if (val !== undefined)\r\n            acc[key] = val;\r\n        return acc;\r\n    }, {});\r\n}\r\nfunction sleep(ms) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, ms); })];\r\n                case 1: return [2 /*return*/, _a.sent()];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction addProtocolIfNotPresent(host) {\r\n    if (!(host.startsWith('https://') || host.startsWith('http://'))) {\r\n        return \"http://\".concat(host);\r\n    }\r\n    return host;\r\n}\r\nfunction addTrailingSlash(url) {\r\n    if (!url.endsWith('/')) {\r\n        url += '/';\r\n    }\r\n    return url;\r\n}\n\nfunction constructHostURL(host) {\r\n    try {\r\n        host = addProtocolIfNotPresent(host);\r\n        host = addTrailingSlash(host);\r\n        return host;\r\n    }\r\n    catch (e) {\r\n        throw new MeiliSearchError('The provided host is not valid.');\r\n    }\r\n}\r\nvar HttpRequests = /** @class */ (function () {\r\n    function HttpRequests(config) {\r\n        this.headers = Object.assign({}, config.headers || {}); // assign to avoid referencing\r\n        this.headers['Content-Type'] = 'application/json';\r\n        if (config.apiKey) {\r\n            this.headers['Authorization'] = \"Bearer \".concat(config.apiKey);\r\n        }\r\n        try {\r\n            var host = constructHostURL(config.host);\r\n            this.url = new URL(host);\r\n        }\r\n        catch (e) {\r\n            throw new MeiliSearchError('The provided host is not valid.');\r\n        }\r\n    }\r\n    HttpRequests.prototype.request = function (_a) {\r\n        var method = _a.method, url = _a.url, params = _a.params, body = _a.body, config = _a.config;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var constructURL, queryParams_1, response, parsedBody, parsedJson, e_1, stack;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        constructURL = new URL(url, this.url);\r\n                        if (params) {\r\n                            queryParams_1 = new URLSearchParams();\r\n                            Object.keys(params)\r\n                                .filter(function (x) { return params[x] !== null; })\r\n                                .map(function (x) { return queryParams_1.set(x, params[x]); });\r\n                            constructURL.search = queryParams_1.toString();\r\n                        }\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 4, , 5]);\r\n                        return [4 /*yield*/, fetch(constructURL.toString(), __assign(__assign({}, config), { method: method, body: JSON.stringify(body), headers: this.headers })).then(function (res) { return httpResponseErrorHandler(res); })];\r\n                    case 2:\r\n                        response = _b.sent();\r\n                        return [4 /*yield*/, response.text()];\r\n                    case 3:\r\n                        parsedBody = _b.sent();\r\n                        try {\r\n                            parsedJson = JSON.parse(parsedBody);\r\n                            return [2 /*return*/, parsedJson];\r\n                        }\r\n                        catch (_) {\r\n                            return [2 /*return*/];\r\n                        }\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        e_1 = _b.sent();\r\n                        stack = e_1.stack;\r\n                        httpErrorHandler(e_1, stack, constructURL.toString());\r\n                        return [3 /*break*/, 5];\r\n                    case 5: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpRequests.prototype.get = function (url, params, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.request({\r\n                            method: 'GET',\r\n                            url: url,\r\n                            params: params,\r\n                            config: config\r\n                        })];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpRequests.prototype.post = function (url, data, params, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.request({\r\n                            method: 'POST',\r\n                            url: url,\r\n                            body: data,\r\n                            params: params,\r\n                            config: config\r\n                        })];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpRequests.prototype.put = function (url, data, params, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.request({\r\n                            method: 'PUT',\r\n                            url: url,\r\n                            body: data,\r\n                            params: params,\r\n                            config: config\r\n                        })];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpRequests.prototype.patch = function (url, data, params, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.request({\r\n                            method: 'PATCH',\r\n                            url: url,\r\n                            body: data,\r\n                            params: params,\r\n                            config: config\r\n                        })];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpRequests.prototype[\"delete\"] = function (url, data, params, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.request({\r\n                            method: 'DELETE',\r\n                            url: url,\r\n                            body: data,\r\n                            params: params,\r\n                            config: config\r\n                        })];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return HttpRequests;\r\n}());\n\nvar TaskClient = /** @class */ (function () {\r\n    function TaskClient(config) {\r\n        this.httpRequest = new HttpRequests(config);\r\n    }\r\n    TaskClient.prototype.getClientTask = function (uid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"tasks/\".concat(uid);\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TaskClient.prototype.getClientTasks = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"tasks\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TaskClient.prototype.getIndexTask = function (indexUid, taskId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(indexUid, \"/tasks/\").concat(taskId);\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TaskClient.prototype.getIndexTasks = function (indexUid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(indexUid, \"/tasks\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Wait for a task to be processed.\r\n     *\r\n     * @param {number} uid Task identifier\r\n     * @param {WaitOptions} options Additional configuration options\r\n     * @returns {Promise<Task>} Promise returning a task after it has been processed\r\n     */\r\n    TaskClient.prototype.waitForClientTask = function (taskId, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var startingTime, response;\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0:\r\n                        startingTime = Date.now();\r\n                        _e.label = 1;\r\n                    case 1:\r\n                        if (!(Date.now() - startingTime < timeOutMs)) return [3 /*break*/, 4];\r\n                        return [4 /*yield*/, this.getClientTask(taskId)];\r\n                    case 2:\r\n                        response = _e.sent();\r\n                        if (![\"enqueued\" /* TASK_ENQUEUED */, \"processing\" /* TASK_PROCESSING */].includes(response.status))\r\n                            return [2 /*return*/, response];\r\n                        return [4 /*yield*/, sleep(intervalMs)];\r\n                    case 3:\r\n                        _e.sent();\r\n                        return [3 /*break*/, 1];\r\n                    case 4: throw new MeiliSearchTimeOutError(\"timeout of \".concat(timeOutMs, \"ms has exceeded on process \").concat(taskId, \" when waiting a task to be resolved.\"));\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Waits for multiple tasks to be processed\r\n     *\r\n     * @param {number} taskIds Tasks identifier list\r\n     * @param {WaitOptions} options Wait options\r\n     * @returns {Promise<Result<Task[]>>} Promise returning a list of tasks after they have been processed\r\n     */\r\n    TaskClient.prototype.waitForClientTasks = function (taskIds, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var tasks, _i, taskIds_1, taskId, task;\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0:\r\n                        tasks = [];\r\n                        _i = 0, taskIds_1 = taskIds;\r\n                        _e.label = 1;\r\n                    case 1:\r\n                        if (!(_i < taskIds_1.length)) return [3 /*break*/, 4];\r\n                        taskId = taskIds_1[_i];\r\n                        return [4 /*yield*/, this.waitForClientTask(taskId, {\r\n                                timeOutMs: timeOutMs,\r\n                                intervalMs: intervalMs\r\n                            })];\r\n                    case 2:\r\n                        task = _e.sent();\r\n                        tasks.push(task);\r\n                        _e.label = 3;\r\n                    case 3:\r\n                        _i++;\r\n                        return [3 /*break*/, 1];\r\n                    case 4: return [2 /*return*/, { results: tasks }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Waits for a task to be processed\r\n     *\r\n     * @param {number} taskId Task identifier\r\n     * @param {WaitOptions} options Wait options\r\n     * @returns {Promise<Task>} Promise returning a task after it has been processed\r\n     */\r\n    TaskClient.prototype.waitForIndexTask = function (indexUid, taskId, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var startingTime, response;\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0:\r\n                        startingTime = Date.now();\r\n                        _e.label = 1;\r\n                    case 1:\r\n                        if (!(Date.now() - startingTime < timeOutMs)) return [3 /*break*/, 4];\r\n                        return [4 /*yield*/, this.getIndexTask(indexUid, taskId)];\r\n                    case 2:\r\n                        response = _e.sent();\r\n                        if (![\"enqueued\" /* TASK_ENQUEUED */, \"processing\" /* TASK_PROCESSING */].includes(response.status))\r\n                            return [2 /*return*/, response];\r\n                        return [4 /*yield*/, sleep(intervalMs)];\r\n                    case 3:\r\n                        _e.sent();\r\n                        return [3 /*break*/, 1];\r\n                    case 4: throw new MeiliSearchTimeOutError(\"timeout of \".concat(timeOutMs, \"ms has exceeded on process \").concat(taskId, \" when waiting for pending update to resolve.\"));\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return TaskClient;\r\n}());\n\n/*\r\n * Bundle: MeiliSearch / Indexes\r\n * Project: MeiliSearch - Javascript API\r\n * Author: Quentin de Quelen <quentin@meilisearch.com>\r\n * Copyright: 2019, MeiliSearch\r\n */\r\nvar Index = /** @class */ (function () {\r\n    /**\r\n     * @param {Config} config Request configuration options\r\n     * @param {string} uid UID of the index\r\n     * @param {string} primaryKey? Primary Key of the index\r\n     */\r\n    function Index(config, uid, primaryKey) {\r\n        this.uid = uid;\r\n        this.primaryKey = primaryKey;\r\n        this.httpRequest = new HttpRequests(config);\r\n        this.tasks = new TaskClient(config);\r\n    }\r\n    ///\r\n    /// SEARCH\r\n    ///\r\n    /**\r\n     * Search for documents into an index\r\n     * @memberof Index\r\n     * @method search\r\n     * @template T\r\n     * @param {string | null} query? Query string\r\n     * @param {SearchParams} options? Search options\r\n     * @param {Partial<Request>} config? Additional request configuration options\r\n     * @returns {Promise<SearchResponse<T>>} Promise containing the search response\r\n     */\r\n    Index.prototype.search = function (query, options, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/search\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, removeUndefinedFromObject(__assign(__assign({}, options), { q: query })), undefined, config)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Search for documents into an index using the GET method\r\n     * @memberof Index\r\n     * @method search\r\n     * @template T\r\n     * @param {string | null} query? Query string\r\n     * @param {SearchParams} options? Search options\r\n     * @param {Partial<Request>} config? Additional request configuration options\r\n     * @returns {Promise<SearchResponse<T>>} Promise containing the search response\r\n     */\r\n    Index.prototype.searchGet = function (query, options, config) {\r\n        var _a, _b, _c, _d, _e;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, parseFilter, getParams;\r\n            return __generator(this, function (_f) {\r\n                switch (_f.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/search\");\r\n                        parseFilter = function (filter) {\r\n                            if (typeof filter === 'string')\r\n                                return filter;\r\n                            else if (Array.isArray(filter))\r\n                                throw new MeiliSearchError('The filter query parameter should be in string format when using searchGet');\r\n                            else\r\n                                return undefined;\r\n                        };\r\n                        getParams = __assign(__assign({ q: query }, options), { filter: parseFilter(options === null || options === void 0 ? void 0 : options.filter), sort: (_a = options === null || options === void 0 ? void 0 : options.sort) === null || _a === void 0 ? void 0 : _a.join(','), facetsDistribution: (_b = options === null || options === void 0 ? void 0 : options.facetsDistribution) === null || _b === void 0 ? void 0 : _b.join(','), attributesToRetrieve: (_c = options === null || options === void 0 ? void 0 : options.attributesToRetrieve) === null || _c === void 0 ? void 0 : _c.join(','), attributesToCrop: (_d = options === null || options === void 0 ? void 0 : options.attributesToCrop) === null || _d === void 0 ? void 0 : _d.join(','), attributesToHighlight: (_e = options === null || options === void 0 ? void 0 : options.attributesToHighlight) === null || _e === void 0 ? void 0 : _e.join(',') });\r\n                        return [4 /*yield*/, this.httpRequest.get(url, removeUndefinedFromObject(getParams), config)];\r\n                    case 1: return [2 /*return*/, _f.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// INDEX\r\n    ///\r\n    /**\r\n     * Get index information.\r\n     * @memberof Index\r\n     * @method getRawInfo\r\n     * @returns {Promise<IndexResponse>} Promise containing index information\r\n     */\r\n    Index.prototype.getRawInfo = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, res;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid);\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1:\r\n                        res = _a.sent();\r\n                        this.primaryKey = res.primaryKey;\r\n                        return [2 /*return*/, res];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Fetch and update Index information.\r\n     * @memberof Index\r\n     * @method fetchInfo\r\n     * @returns {Promise<this>} Promise to the current Index object with updated information\r\n     */\r\n    Index.prototype.fetchInfo = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.getRawInfo()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get Primary Key.\r\n     * @memberof Index\r\n     * @method fetchPrimaryKey\r\n     * @returns {Promise<string | undefined>} Promise containing the Primary Key of the index\r\n     */\r\n    Index.prototype.fetchPrimaryKey = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this;\r\n                        return [4 /*yield*/, this.getRawInfo()];\r\n                    case 1:\r\n                        _a.primaryKey = (_b.sent()).primaryKey;\r\n                        return [2 /*return*/, this.primaryKey];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Create an index.\r\n     * @memberof Index\r\n     * @method create\r\n     * @template T\r\n     * @param {string} uid Unique identifier of the Index\r\n     * @param {IndexOptions} options Index options\r\n     * @param {Config} config Request configuration options\r\n     * @returns {Promise<Index<T>>} Newly created Index object\r\n     */\r\n    Index.create = function (uid, options, config) {\r\n        if (options === void 0) { options = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, req;\r\n            return __generator(this, function (_a) {\r\n                url = \"indexes\";\r\n                req = new HttpRequests(config);\r\n                return [2 /*return*/, req.post(url, __assign(__assign({}, options), { uid: uid }))];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update an index.\r\n     * @memberof Index\r\n     * @method update\r\n     * @param {IndexOptions} data Data to update\r\n     * @returns {Promise<this>} Promise to the current Index object with updated information\r\n     */\r\n    Index.prototype.update = function (data) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid);\r\n                        return [4 /*yield*/, this.httpRequest.put(url, data)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete an index.\r\n     * @memberof Index\r\n     * @method delete\r\n     * @returns {Promise<void>} Promise which resolves when index is deleted successfully\r\n     */\r\n    Index.prototype[\"delete\"] = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid);\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// TASKS\r\n    ///\r\n    /**\r\n     * Get the list of all the index tasks.\r\n     *\r\n     * @memberof Indexes\r\n     * @method getTasks\r\n     *\r\n     * @returns {Promise<Result<Task[]>>} - Promise containing all tasks\r\n     */\r\n    Index.prototype.getTasks = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.getIndexTasks(this.uid)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get one task of the index.\r\n     *\r\n     * @memberof Indexes\r\n     * @method getTask\r\n     * @param {number} taskId - Task identifier\r\n     *\r\n     * @returns {Promise<Task>} - Promise containing a task\r\n     */\r\n    Index.prototype.getTask = function (taskId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.getIndexTask(this.uid, taskId)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Wait for a batch of an index tasks to be processed.\r\n     *\r\n     * @memberof Indexes\r\n     * @method waitForTasks\r\n     * @param {number[]} taskIds - Tasks identifier\r\n     * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n     *\r\n     * @returns {Promise<Result<Task[]>>} - Promise containing an array of tasks\r\n     */\r\n    Index.prototype.waitForTasks = function (taskIds, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.waitForClientTasks(taskIds, {\r\n                            timeOutMs: timeOutMs,\r\n                            intervalMs: intervalMs\r\n                        })];\r\n                    case 1: return [2 /*return*/, _e.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Wait for an index task to be processed.\r\n     *\r\n     * @memberof Indexes\r\n     * @method waitForTask\r\n     * @param {number} taskId - Task identifier\r\n     * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n     *\r\n     * @returns {Promise<Task>} - Promise containing an array of tasks\r\n     */\r\n    Index.prototype.waitForTask = function (taskId, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.waitForClientTask(taskId, {\r\n                            timeOutMs: timeOutMs,\r\n                            intervalMs: intervalMs\r\n                        })];\r\n                    case 1: return [2 /*return*/, _e.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// STATS\r\n    ///\r\n    /**\r\n     * get stats of an index\r\n     * @memberof Index\r\n     * @method getStats\r\n     * @returns {Promise<IndexStats>} Promise containing object with stats of the index\r\n     */\r\n    Index.prototype.getStats = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/stats\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// DOCUMENTS\r\n    ///\r\n    /**\r\n     * get documents of an index\r\n     * @memberof Index\r\n     * @method getDocuments\r\n     * @template T\r\n     * @param {GetDocumentsParams<T>} options? Options to browse the documents\r\n     * @returns {Promise<GetDocumentsResponse<T>>} Promise containing Document responses\r\n     */\r\n    Index.prototype.getDocuments = function (options) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, attr;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\r\n                        if (options !== undefined && Array.isArray(options.attributesToRetrieve)) {\r\n                            attr = options.attributesToRetrieve.join(',');\r\n                        }\r\n                        return [4 /*yield*/, this.httpRequest.get(url, __assign(__assign({}, options), (attr !== undefined ? { attributesToRetrieve: attr } : {})))];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get one document\r\n     * @memberof Index\r\n     * @method getDocument\r\n     * @template T\r\n     * @param {string | number} documentId Document ID\r\n     * @returns {Promise<Document<T>>} Promise containing Document response\r\n     */\r\n    Index.prototype.getDocument = function (documentId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents/\").concat(documentId);\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Add or replace multiples documents to an index\r\n     * @memberof Index\r\n     * @method addDocuments\r\n     * @template T\r\n     * @param {Array<Document<T>>} documents Array of Document objects to add/replace\r\n     * @param {AddDocumentParams} options? Query parameters\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.addDocuments = function (documents, options) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, documents, options)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Add or replace multiples documents to an index in batches\r\n     * @memberof Index\r\n     * @method addDocumentsInBatches\r\n     * @template T\r\n     * @param {Array<Document<T>>} documents Array of Document objects to add/replace\r\n     * @param {number} batchSize Size of the batch\r\n     * @param {AddDocumentParams} options? Query parameters\r\n     * @returns {Promise<EnqueuedTasks>} Promise containing array of enqueued update objects for each batch\r\n     */\r\n    Index.prototype.addDocumentsInBatches = function (documents, batchSize, options) {\r\n        if (batchSize === void 0) { batchSize = 1000; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var updates, i, _a, _b;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        updates = [];\r\n                        i = 0;\r\n                        _c.label = 1;\r\n                    case 1:\r\n                        if (!(i < documents.length)) return [3 /*break*/, 4];\r\n                        _b = (_a = updates).push;\r\n                        return [4 /*yield*/, this.addDocuments(documents.slice(i, i + batchSize), options)];\r\n                    case 2:\r\n                        _b.apply(_a, [_c.sent()]);\r\n                        _c.label = 3;\r\n                    case 3:\r\n                        i += batchSize;\r\n                        return [3 /*break*/, 1];\r\n                    case 4: return [2 /*return*/, updates];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Add or update multiples documents to an index\r\n     * @memberof Index\r\n     * @method updateDocuments\r\n     * @param {Array<Document<Partial<T>>>} documents Array of Document objects to add/update\r\n     * @param {AddDocumentParams} options? Query parameters\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.updateDocuments = function (documents, options) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\r\n                        return [4 /*yield*/, this.httpRequest.put(url, documents, options)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Add or update multiples documents to an index in batches\r\n     * @memberof Index\r\n     * @method updateDocuments\r\n     * @template T\r\n     * @param {Array<Document<T>>} documents Array of Document objects to add/update\r\n     * @param {number} batchSize Size of the batch\r\n     * @param {AddDocumentParams} options? Query parameters\r\n     * @returns {Promise<EnqueuedTasks>} Promise containing array of enqueued update objects for each batch\r\n     */\r\n    Index.prototype.updateDocumentsInBatches = function (documents, batchSize, options) {\r\n        if (batchSize === void 0) { batchSize = 1000; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var updates, i, _a, _b;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        updates = [];\r\n                        i = 0;\r\n                        _c.label = 1;\r\n                    case 1:\r\n                        if (!(i < documents.length)) return [3 /*break*/, 4];\r\n                        _b = (_a = updates).push;\r\n                        return [4 /*yield*/, this.updateDocuments(documents.slice(i, i + batchSize), options)];\r\n                    case 2:\r\n                        _b.apply(_a, [_c.sent()]);\r\n                        _c.label = 3;\r\n                    case 3:\r\n                        i += batchSize;\r\n                        return [3 /*break*/, 1];\r\n                    case 4: return [2 /*return*/, updates];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete one document\r\n     * @memberof Index\r\n     * @method deleteDocument\r\n     * @param {string | number} documentId Id of Document to delete\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */\r\n    Index.prototype.deleteDocument = function (documentId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents/\").concat(documentId);\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete multiples documents of an index\r\n     * @memberof Index\r\n     * @method deleteDocuments\r\n     * @param {string[] | number[]} documentsIds Array of Document Ids to delete\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */\r\n    Index.prototype.deleteDocuments = function (documentsIds) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents/delete-batch\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, documentsIds)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete all documents of an index\r\n     * @memberof Index\r\n     * @method deleteAllDocuments\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */\r\n    Index.prototype.deleteAllDocuments = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// SETTINGS\r\n    ///\r\n    /**\r\n     * Retrieve all settings\r\n     * @memberof Index\r\n     * @method getSettings\r\n     * @returns {Promise<Settings>} Promise containing Settings object\r\n     */\r\n    Index.prototype.getSettings = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update all settings\r\n     * Any parameters not provided will be left unchanged.\r\n     * @memberof Index\r\n     * @method updateSettings\r\n     * @param {Settings} settings Object containing parameters with their updated values\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */\r\n    Index.prototype.updateSettings = function (settings) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, settings)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset settings.\r\n     * @memberof Index\r\n     * @method resetSettings\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */\r\n    Index.prototype.resetSettings = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// SYNONYMS\r\n    ///\r\n    /**\r\n     * Get the list of all synonyms\r\n     * @memberof Index\r\n     * @method getSynonyms\r\n     * @returns {Promise<object>} Promise containing object of synonym mappings\r\n     */\r\n    Index.prototype.getSynonyms = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the list of synonyms. Overwrite the old list.\r\n     * @memberof Index\r\n     * @method updateSynonyms\r\n     * @param {Synonyms} synonyms Mapping of synonyms with their associated words\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */\r\n    Index.prototype.updateSynonyms = function (synonyms) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, synonyms)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the synonym list to be empty again\r\n     * @memberof Index\r\n     * @method resetSynonyms\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */\r\n    Index.prototype.resetSynonyms = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// STOP WORDS\r\n    ///\r\n    /**\r\n     * Get the list of all stop-words\r\n     * @memberof Index\r\n     * @method getStopWords\r\n     * @returns {Promise<string[]>} Promise containing array of stop-words\r\n     */\r\n    Index.prototype.getStopWords = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the list of stop-words. Overwrite the old list.\r\n     * @memberof Index\r\n     * @method updateStopWords\r\n     * @param {StopWords} stopWords Array of strings that contains the stop-words.\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.updateStopWords = function (stopWords) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, stopWords)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the stop-words list to be empty again\r\n     * @memberof Index\r\n     * @method resetStopWords\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.resetStopWords = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// RANKING RULES\r\n    ///\r\n    /**\r\n     * Get the list of all ranking-rules\r\n     * @memberof Index\r\n     * @method getRankingRules\r\n     * @returns {Promise<string[]} Promise containing array of ranking-rules\r\n     */\r\n    Index.prototype.getRankingRules = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the list of ranking-rules. Overwrite the old list.\r\n     * @memberof Index\r\n     * @method updateRankingRules\r\n     * @param {RankingRules} rankingRules Array that contain ranking rules sorted by order of importance.\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.updateRankingRules = function (rankingRules) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, rankingRules)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the ranking rules list to its default value\r\n     * @memberof Index\r\n     * @method resetRankingRules\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.resetRankingRules = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// DISTINCT ATTRIBUTE\r\n    ///\r\n    /**\r\n     * Get the distinct-attribute\r\n     * @memberof Index\r\n     * @method getDistinctAttribute\r\n     * @returns {Promise<string | null>} Promise containing the distinct-attribute of the index\r\n     */\r\n    Index.prototype.getDistinctAttribute = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the distinct-attribute.\r\n     * @memberof Index\r\n     * @method updateDistinctAttribute\r\n     * @param {DistinctAttribute} distinctAttribute Field name of the distinct-attribute\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.updateDistinctAttribute = function (distinctAttribute) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, distinctAttribute)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the distinct-attribute.\r\n     * @memberof Index\r\n     * @method resetDistinctAttribute\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.resetDistinctAttribute = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// FILTERABLE ATTRIBUTES\r\n    ///\r\n    /**\r\n     * Get the filterable-attributes\r\n     * @memberof Index\r\n     * @method getFilterableAttributes\r\n     * @returns {Promise<string[]>} Promise containing an array of filterable-attributes\r\n     */\r\n    Index.prototype.getFilterableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the filterable-attributes.\r\n     * @memberof Index\r\n     * @method updateFilterableAttributes\r\n     * @param {FilterableAttributes} filterableAttributes Array of strings containing the attributes that can be used as filters at query time\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.updateFilterableAttributes = function (filterableAttributes) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, filterableAttributes)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the filterable-attributes.\r\n     * @memberof Index\r\n     * @method resetFilterableAttributes\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.resetFilterableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// SORTABLE ATTRIBUTES\r\n    ///\r\n    /**\r\n     * Get the sortable-attributes\r\n     * @memberof Index\r\n     * @method getSortableAttributes\r\n     * @returns {Promise<string[]>} Promise containing array of sortable-attributes\r\n     */\r\n    Index.prototype.getSortableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the sortable-attributes.\r\n     * @memberof Index\r\n     * @method updateSortableAttributes\r\n     * @param {SortableAttributes} sortableAttributes Array of strings containing the attributes that can be used to sort search results at query time\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */\r\n    Index.prototype.updateSortableAttributes = function (sortableAttributes) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, sortableAttributes)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the sortable-attributes.\r\n     * @memberof Index\r\n     * @method resetSortableAttributes\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */\r\n    Index.prototype.resetSortableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// SEARCHABLE ATTRIBUTE\r\n    ///\r\n    /**\r\n     * Get the searchable-attributes\r\n     * @memberof Index\r\n     * @method getSearchableAttributes\r\n     * @returns {Promise<string[]>} Promise containing array of searchable-attributes\r\n     */\r\n    Index.prototype.getSearchableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the searchable-attributes.\r\n     * @memberof Index\r\n     * @method updateSearchableAttributes\r\n     * @param {SearchableAttributes} searchableAttributes Array of strings that contains searchable attributes sorted by order of importance(most to least important)\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */\r\n    Index.prototype.updateSearchableAttributes = function (searchableAttributes) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, searchableAttributes)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the searchable-attributes.\r\n     * @memberof Index\r\n     * @method resetSearchableAttributes\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */\r\n    Index.prototype.resetSearchableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// DISPLAYED ATTRIBUTE\r\n    ///\r\n    /**\r\n     * Get the displayed-attributes\r\n     * @memberof Index\r\n     * @method getDisplayedAttributes\r\n     * @returns {Promise<string[]>} Promise containing array of displayed-attributes\r\n     */\r\n    Index.prototype.getDisplayedAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the displayed-attributes.\r\n     * @memberof Index\r\n     * @method updateDisplayedAttributes\r\n     * @param {DisplayedAttributes} displayedAttributes Array of strings that contains attributes of an index to display\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.updateDisplayedAttributes = function (displayedAttributes) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, displayedAttributes)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the displayed-attributes.\r\n     * @memberof Index\r\n     * @method resetDisplayedAttributes\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.resetDisplayedAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// TYPO TOLERANCE\r\n    ///\r\n    /**\r\n     * Get the typo tolerance settings.\r\n     * @memberof Index\r\n     * @method getTypoTolerance\r\n     * @returns {Promise<string[]>} Promise containing the typo tolerance settings.\r\n     */\r\n    Index.prototype.getTypoTolerance = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the typo tolerance settings.\r\n     * @memberof Index\r\n     * @method updateTypoTolerance\r\n     * @param {TypoTolerance} typoTolerance Object containing the custom typo tolerance settings.\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.updateTypoTolerance = function (typoTolerance) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, typoTolerance)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the typo tolerance settings.\r\n     * @memberof Index\r\n     * @method resetTypoTolerance\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.resetTypoTolerance = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return Index;\r\n}());\n\n/*\r\n * Bundle: MeiliSearch\r\n * Project: MeiliSearch - Javascript API\r\n * Author: Quentin de Quelen <quentin@meilisearch.com>\r\n * Copyright: 2019, MeiliSearch\r\n */\r\nvar Client = /** @class */ (function () {\r\n    /**\r\n     * Creates new MeiliSearch instance\r\n     * @param {Config} config Configuration object\r\n     */\r\n    function Client(config) {\r\n        this.config = config;\r\n        this.httpRequest = new HttpRequests(config);\r\n        this.tasks = new TaskClient(config);\r\n    }\r\n    /**\r\n     * Return an Index instance\r\n     * @memberof MeiliSearch\r\n     * @method index\r\n     * @template T\r\n     * @param {string} indexUid The index UID\r\n     * @returns {Index<T>} Instance of Index\r\n     */\r\n    Client.prototype.index = function (indexUid) {\r\n        return new Index(this.config, indexUid);\r\n    };\r\n    /**\r\n     * Gather information about an index by calling MeiliSearch and\r\n     * return an Index instance with the gathered information\r\n     * @memberof MeiliSearch\r\n     * @method getIndex\r\n     * @template T\r\n     * @param {string} indexUid The index UID\r\n     * @returns {Promise<Index<T>>} Promise returning Index instance\r\n     */\r\n    Client.prototype.getIndex = function (indexUid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, new Index(this.config, indexUid).fetchInfo()];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Gather information about an index by calling MeiliSearch and\r\n     * return the raw JSON response\r\n     * @memberof MeiliSearch\r\n     * @method getRawIndex\r\n     * @param {string} indexUid The index UID\r\n     * @returns {Promise<IndexResponse>} Promise returning index information\r\n     */\r\n    Client.prototype.getRawIndex = function (indexUid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, new Index(this.config, indexUid).getRawInfo()];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get all the indexes as Index instances.\r\n     * @memberof MeiliSearch\r\n     * @method getIndexes\r\n     * @returns {Promise<Index[]>} Promise returning array of raw index information\r\n     */\r\n    Client.prototype.getIndexes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var response, indexes;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.getRawIndexes()];\r\n                    case 1:\r\n                        response = _a.sent();\r\n                        indexes = response.map(function (index) { return new Index(_this.config, index.uid, index.primaryKey); });\r\n                        return [2 /*return*/, indexes];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get all the indexes in their raw value (no Index instances).\r\n     * @memberof MeiliSearch\r\n     * @method getRawIndexes\r\n     * @returns {Promise<IndexResponse[]>} Promise returning array of raw index information\r\n     */\r\n    Client.prototype.getRawIndexes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Create a new index\r\n     * @memberof MeiliSearch\r\n     * @method createIndex\r\n     * @template T\r\n     * @param {string} uid The index UID\r\n     * @param {IndexOptions} options Index options\r\n     * @returns {Promise<Index<T>>} Promise returning Index instance\r\n     */\r\n    Client.prototype.createIndex = function (uid, options) {\r\n        if (options === void 0) { options = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, Index.create(uid, options, this.config)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update an index\r\n     * @memberof MeiliSearch\r\n     * @method updateIndex\r\n     * @template T\r\n     * @param {string} uid The index UID\r\n     * @param {IndexOptions} options Index options to update\r\n     * @returns {Promise<Index<T>>} Promise returning Index instance after updating\r\n     */\r\n    Client.prototype.updateIndex = function (uid, options) {\r\n        if (options === void 0) { options = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, new Index(this.config, uid).update(options)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete an index\r\n     * @memberof MeiliSearch\r\n     * @method deleteIndex\r\n     * @param {string} uid The index UID\r\n     * @returns {Promise<void>} Promise which resolves when index is deleted successfully\r\n     */\r\n    Client.prototype.deleteIndex = function (uid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, new Index(this.config, uid)[\"delete\"]()];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Deletes an index if it already exists.\r\n     * @memberof MeiliSearch\r\n     * @method deleteIndexIfExists\r\n     * @param {string} uid The index UID\r\n     * @returns {Promise<boolean>} Promise which resolves to true when index exists and is deleted successfully, otherwise false if it does not exist\r\n     */\r\n    Client.prototype.deleteIndexIfExists = function (uid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var e_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        return [4 /*yield*/, this.deleteIndex(uid)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, true];\r\n                    case 2:\r\n                        e_1 = _a.sent();\r\n                        if (e_1.code === \"index_not_found\" /* INDEX_NOT_FOUND */) {\r\n                            return [2 /*return*/, false];\r\n                        }\r\n                        throw e_1;\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// TASKS\r\n    ///\r\n    /**\r\n     * Get the list of all client tasks\r\n     * @memberof MeiliSearch\r\n     * @method getTasks\r\n     * @returns {Promise<Result<Task[]>>} - Promise returning all tasks\r\n     */\r\n    Client.prototype.getTasks = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.getClientTasks()];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get one task on the client scope\r\n     * @memberof MeiliSearch\r\n     * @method getTask\r\n     * @param {number} taskId - Task identifier\r\n     * @returns {Promise<Task>} - Promise returning a task\r\n     */\r\n    Client.prototype.getTask = function (taskId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.getClientTask(taskId)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Wait for a batch of tasks to be processed.\r\n     * @memberof MeiliSearch\r\n     * @method waitForTasks\r\n     * @param {number[]} taskIds - Tasks identifier\r\n     * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n     *\r\n     * @returns {Promise<Result<Task[]>>} - Promise returning an array of tasks\r\n     */\r\n    Client.prototype.waitForTasks = function (taskIds, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.waitForClientTasks(taskIds, {\r\n                            timeOutMs: timeOutMs,\r\n                            intervalMs: intervalMs\r\n                        })];\r\n                    case 1: return [2 /*return*/, _e.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Wait for a task to be processed.\r\n     *\r\n     * @memberof MeiliSearch\r\n     * @method waitForTask\r\n     * @param {number} taskId - Task identifier\r\n     * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n     *\r\n     * @returns {Promise<Task>} - Promise returning an array of tasks\r\n     */\r\n    Client.prototype.waitForTask = function (taskId, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.waitForClientTask(taskId, {\r\n                            timeOutMs: timeOutMs,\r\n                            intervalMs: intervalMs\r\n                        })];\r\n                    case 1: return [2 /*return*/, _e.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// KEYS\r\n    ///\r\n    /**\r\n     * Get all API keys\r\n     * @memberof MeiliSearch\r\n     * @method getKeys\r\n     * @returns {Promise<Keys>} Promise returning an object with keys\r\n     */\r\n    Client.prototype.getKeys = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"keys\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get one API key\r\n     * @memberof MeiliSearch\r\n     * @method getKey\r\n     *\r\n     * @param {string} key - Key\r\n     * @returns {Promise<Keys>} Promise returning a key\r\n     */\r\n    Client.prototype.getKey = function (key) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"keys/\".concat(key);\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Create one API key\r\n     * @memberof MeiliSearch\r\n     * @method createKey\r\n     *\r\n     * @param {KeyPayload} options - Key options\r\n     * @returns {Promise<Key>} Promise returning an object with keys\r\n     */\r\n    Client.prototype.createKey = function (options) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"keys\";\r\n                        return [4 /*yield*/, this.httpRequest.post(url, options)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update one API key\r\n     * @memberof MeiliSearch\r\n     * @method updateKey\r\n     *\r\n     * @param {string} key - Key\r\n     * @param {KeyPayload} options - Key options\r\n     * @returns {Promise<Key>} Promise returning an object with keys\r\n     */\r\n    Client.prototype.updateKey = function (key, options) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"keys/\".concat(key);\r\n                        return [4 /*yield*/, this.httpRequest.patch(url, options)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete one API key\r\n     * @memberof MeiliSearch\r\n     * @method deleteKey\r\n     *\r\n     * @param {string} key - Key\r\n     * @returns {Promise<Void>}\r\n     */\r\n    Client.prototype.deleteKey = function (key) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"keys/\".concat(key);\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// HEALTH\r\n    ///\r\n    /**\r\n     * Checks if the server is healthy, otherwise an error will be thrown.\r\n     * @memberof MeiliSearch\r\n     * @method health\r\n     * @returns {Promise<Health>} Promise returning an object with health details\r\n     */\r\n    Client.prototype.health = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"health\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Checks if the server is healthy, return true or false.\r\n     * @memberof MeiliSearch\r\n     * @method isHealthy\r\n     * @returns {Promise<boolean>} Promise returning a boolean\r\n     */\r\n    Client.prototype.isHealthy = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        url = \"health\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, true];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2 /*return*/, false];\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// STATS\r\n    ///\r\n    /**\r\n     * Get the stats of all the database\r\n     * @memberof MeiliSearch\r\n     * @method getStats\r\n     * @returns {Promise<Stats>} Promise returning object of all the stats\r\n     */\r\n    Client.prototype.getStats = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"stats\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// VERSION\r\n    ///\r\n    /**\r\n     * Get the version of MeiliSearch\r\n     * @memberof MeiliSearch\r\n     * @method getVersion\r\n     * @returns {Promise<Version>} Promise returning object with version details\r\n     */\r\n    Client.prototype.getVersion = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"version\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// DUMPS\r\n    ///\r\n    /**\r\n     * Triggers a dump creation process\r\n     * @memberof MeiliSearch\r\n     * @method createDump\r\n     * @returns {Promise<EnqueuedDump>} Promise returning object of the enqueued update\r\n     */\r\n    Client.prototype.createDump = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"dumps\";\r\n                        return [4 /*yield*/, this.httpRequest.post(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get the status of a dump creation process\r\n     * @memberof MeiliSearch\r\n     * @method getDumpStatus\r\n     * @param {string} dumpUid Dump UID\r\n     * @returns {Promise<EnqueuedDump>} Promise returning object of the enqueued update\r\n     */\r\n    Client.prototype.getDumpStatus = function (dumpUid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"dumps/\".concat(dumpUid, \"/status\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Generate a tenant token\r\n     *\r\n     * @memberof MeiliSearch\r\n     * @method generateTenantToken\r\n     * @param {SearchRules} searchRules Search rules that are applied to every search.\r\n     * @param {TokenOptions} options Token options to customize some aspect of the token.\r\n     * @returns {String} The token in JWT format.\r\n     */\r\n    Client.prototype.generateTenantToken = function (_searchRules, _options) {\r\n        var error = new Error();\r\n        throw new Error(\"Meilisearch: failed to generate a tenant token. Generation of a token only works in a node environment \\n \".concat(error.stack, \".\"));\r\n    };\r\n    return Client;\r\n}());\n\nfunction encode64(data) {\r\n    return Buffer.from(JSON.stringify(data)).toString('base64');\r\n}\r\n/**\r\n * Create the header of the token.\r\n *\r\n * @param {String} apiKey API key used to sign the token.\r\n * @param {String} encodedHeader Header of the token in base64.\r\n * @param {String} encodedPayload Payload of the token in base64.\r\n * @returns {String} The signature of the token in base64.\r\n */\r\nfunction sign(apiKey, encodedHeader, encodedPayload) {\r\n    return crypto__default[\"default\"]\r\n        .createHmac('sha256', apiKey)\r\n        .update(\"\".concat(encodedHeader, \".\").concat(encodedPayload))\r\n        .digest('base64')\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n        .replace(/=/g, '');\r\n}\r\n/**\r\n * Create the header of the token.\r\n *\r\n * @returns {String} The header encoded in base64.\r\n */\r\nfunction createHeader() {\r\n    var header = {\r\n        alg: 'HS256',\r\n        typ: 'JWT'\r\n    };\r\n    return encode64(header).replace(/=/g, '');\r\n}\r\n/**\r\n * Validate the parameter used for the payload of the token.\r\n *\r\n * @param {SearchRules} searchRules Search rules that are applied to every search.\r\n * @param {String} apiKey Api key used as issuer of the token.\r\n * @param {Date | undefined} expiresAt Date at which the token expires.\r\n */\r\nfunction validatePayload(payloadParams) {\r\n    var searchRules = payloadParams.searchRules, apiKey = payloadParams.apiKey, expiresAt = payloadParams.expiresAt;\r\n    var error = new Error();\r\n    if (expiresAt) {\r\n        if (!(expiresAt instanceof Date) || expiresAt.getTime() < Date.now()) {\r\n            throw new Error(\"Meilisearch: When the expiresAt field in the token generation has a value, it must be a date set in the future and not in the past. \\n \".concat(error.stack, \".\"));\r\n        }\r\n    }\r\n    if (searchRules) {\r\n        if (!(typeof searchRules === 'object' || Array.isArray(searchRules))) {\r\n            throw new Error(\"Meilisearch: The search rules added in the token generation must be of type array or object. \\n \".concat(error.stack, \".\"));\r\n        }\r\n    }\r\n    if (!apiKey || typeof apiKey !== 'string') {\r\n        throw new Error(\"Meilisearch: The API key used for the token generation must exist and be of type string. \\n \".concat(error.stack, \".\"));\r\n    }\r\n}\r\n/**\r\n * Create the payload of the token.\r\n *\r\n * @param {SearchRules} searchRules Search rules that are applied to every search.\r\n * @param {String} apiKey Api key used as issuer of the token.\r\n * @param {Date | undefined} expiresAt Date at which the token expires.\r\n * @returns {String} The payload encoded in base64.\r\n */\r\nfunction createPayload(payloadParams) {\r\n    var searchRules = payloadParams.searchRules, apiKey = payloadParams.apiKey, expiresAt = payloadParams.expiresAt;\r\n    validatePayload(payloadParams);\r\n    var payload = {\r\n        searchRules: searchRules,\r\n        apiKeyPrefix: apiKey.substring(0, 8),\r\n        exp: expiresAt === null || expiresAt === void 0 ? void 0 : expiresAt.getTime()\r\n    };\r\n    return encode64(payload).replace(/=/g, '');\r\n}\r\nvar Token = /** @class */ (function () {\r\n    function Token(config) {\r\n        this.config = config;\r\n    }\r\n    /**\r\n     * Generate a tenant token\r\n     *\r\n     * @memberof MeiliSearch\r\n     * @method generateTenantToken\r\n     * @param {SearchRules} searchRules Search rules that are applied to every search.\r\n     * @param {TokenOptions} options Token options to customize some aspect of the token.\r\n     * @returns {String} The token in JWT format.\r\n     */\r\n    Token.prototype.generateTenantToken = function (searchRules, options) {\r\n        var apiKey = (options === null || options === void 0 ? void 0 : options.apiKey) || this.config.apiKey || '';\r\n        var expiresAt = options === null || options === void 0 ? void 0 : options.expiresAt;\r\n        var encodedHeader = createHeader();\r\n        var encodedPayload = createPayload({ searchRules: searchRules, apiKey: apiKey, expiresAt: expiresAt });\r\n        var signature = sign(apiKey, encodedHeader, encodedPayload);\r\n        return \"\".concat(encodedHeader, \".\").concat(encodedPayload, \".\").concat(signature);\r\n    };\r\n    return Token;\r\n}());\n\nvar MeiliSearch = /** @class */ (function (_super) {\r\n    __extends(MeiliSearch, _super);\r\n    function MeiliSearch(config) {\r\n        var _this = _super.call(this, config) || this;\r\n        _this.tokens = new Token(config);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Generate a tenant token\r\n     *\r\n     * @memberof MeiliSearch\r\n     * @method generateTenantToken\r\n     * @param {SearchRules} searchRules Search rules that are applied to every search.\r\n     * @param {TokenOptions} options Token options to customize some aspect of the token.\r\n     * @returns {String} The token in JWT format.\r\n     */\r\n    MeiliSearch.prototype.generateTenantToken = function (searchRules, options) {\r\n        if (typeof window === 'undefined') {\r\n            return this.tokens.generateTenantToken(searchRules, options);\r\n        }\r\n        return _super.prototype.generateTenantToken.call(this, searchRules, options);\r\n    };\r\n    return MeiliSearch;\r\n}(Client));\n\nexports.HttpRequests = HttpRequests;\nexports.Index = Index;\nexports.MeiliSearch = MeiliSearch;\nexports.MeiliSearchApiError = MeiliSearchApiError;\nexports.MeiliSearchCommunicationError = MeiliSearchCommunicationError;\nexports.MeiliSearchError = MeiliSearchError;\nexports.MeiliSearchTimeOutError = MeiliSearchTimeOutError;\nexports.addProtocolIfNotPresent = addProtocolIfNotPresent;\nexports.addTrailingSlash = addTrailingSlash;\nexports[\"default\"] = MeiliSearch;\nexports.httpErrorHandler = httpErrorHandler;\nexports.httpResponseErrorHandler = httpResponseErrorHandler;\nexports.removeUndefinedFromObject = removeUndefinedFromObject;\nexports.sleep = sleep;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVpbGlzZWFyY2gvZGlzdC9idW5kbGVzL21laWxpc2VhcmNoLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELG1CQUFPLENBQUMsb0ZBQXNCO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFN0IscUNBQXFDLDREQUE0RDs7QUFFakc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsaUNBQWlDO0FBQy9HO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LFFBQVE7QUFDbkIsV0FBVyxrQkFBa0I7QUFDN0IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0VBQWdFO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG9CQUFvQjtBQUNwQixhQUFhO0FBQ2IsbUJBQW1CO0FBQ25CLDJCQUEyQjtBQUMzQixxQ0FBcUM7QUFDckMsd0JBQXdCO0FBQ3hCLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0Isd0JBQXdCO0FBQ3hCLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLGlDQUFpQztBQUNqQyxhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvbWVpbGlzZWFyY2gvZGlzdC9idW5kbGVzL21laWxpc2VhcmNoLmNqcy5qcz9mNDNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxucmVxdWlyZSgnY3Jvc3MtZmV0Y2gvcG9seWZpbGwnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBjcnlwdG9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGNyeXB0byk7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cblxudmFyIE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3IobWVzc2FnZSwgYm9keSwgdXJsLCBzdGFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSAnTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3InO1xyXG4gICAgICAgIF90aGlzLnR5cGUgPSAnTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3InO1xyXG4gICAgICAgIGlmIChib2R5IGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgX3RoaXMubWVzc2FnZSA9IGJvZHkuc3RhdHVzVGV4dDtcclxuICAgICAgICAgICAgX3RoaXMuc3RhdHVzQ29kZSA9IGJvZHkuc3RhdHVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYm9keSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmVycm5vID0gYm9keS5lcnJubztcclxuICAgICAgICAgICAgX3RoaXMuY29kZSA9IGJvZHkuY29kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YWNrKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YWNrID0gc3RhY2s7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YWNrID0gKF9hID0gX3RoaXMuc3RhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC8oVHlwZUVycm9yfEZldGNoRXJyb3IpLywgX3RoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YWNrID0gKF9iID0gX3RoaXMuc3RhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXBsYWNlKCdGYWlsZWQgdG8gZmV0Y2gnLCBcInJlcXVlc3QgdG8gXCIuY29uY2F0KHVybCwgXCIgZmFpbGVkLCByZWFzb246IGNvbm5lY3QgRUNPTk5SRUZVU0VEXCIpKTtcclxuICAgICAgICAgICAgX3RoaXMuc3RhY2sgPSAoX2MgPSBfdGhpcy5zdGFjaykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlcGxhY2UoJ05vdCBGb3VuZCcsIFwiTm90IEZvdW5kOiBcIi5jb25jYXQodXJsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBNZWlsaVNlYXJjaENvbW11bmljYXRpb25FcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yO1xyXG59KEVycm9yKSk7XG5cbnZhciBNZWlsaVNlYXJjaEFwaUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBjbGFzc18xKGVycm9yLCBzdGF0dXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlcnJvci5tZXNzYWdlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSAnTWVpbGlTZWFyY2hBcGlFcnJvcic7XHJcbiAgICAgICAgX3RoaXMuY29kZSA9IGVycm9yLmNvZGU7XHJcbiAgICAgICAgX3RoaXMudHlwZSA9IGVycm9yLnR5cGU7XHJcbiAgICAgICAgX3RoaXMubGluayA9IGVycm9yLmxpbms7XHJcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgX3RoaXMuaHR0cFN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICAvLyBNYWtlIGVycm9ycyBjb21wYXJpc29uIHBvc3NpYmxlLiBleDogZXJyb3IgaW5zdGFuY2VvZiBNZWlsaVNlYXJjaEFwaUVycm9yLlxyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWVpbGlTZWFyY2hBcGlFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTWVpbGlTZWFyY2hBcGlFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBjbGFzc18xO1xyXG59KEVycm9yKSk7XG5cbmZ1bmN0aW9uIGh0dHBSZXNwb25zZUVycm9ySGFuZGxlcihyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlcnI7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhcmVzcG9uc2Uub2spIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS5qc29uKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHJlc3BvbnNlLCByZXNwb25zZS51cmwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiB0aHJvdyBuZXcgTWVpbGlTZWFyY2hBcGlFcnJvcihlcnIsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGh0dHBFcnJvckhhbmRsZXIocmVzcG9uc2UsIHN0YWNrLCB1cmwpIHtcclxuICAgIGlmIChyZXNwb25zZS50eXBlICE9PSAnTWVpbGlTZWFyY2hBcGlFcnJvcicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3IocmVzcG9uc2UubWVzc2FnZSwgcmVzcG9uc2UsIHVybCwgc3RhY2spO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgcmVzcG9uc2U7XHJcbn1cblxudmFyIE1laWxpU2VhcmNoRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWVpbGlTZWFyY2hFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1laWxpU2VhcmNoRXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubmFtZSA9ICdNZWlsaVNlYXJjaEVycm9yJztcclxuICAgICAgICBfdGhpcy50eXBlID0gJ01laWxpU2VhcmNoRXJyb3InO1xyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTWVpbGlTZWFyY2hFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBNZWlsaVNlYXJjaEVycm9yO1xyXG59KEVycm9yKSk7XG5cbnZhciBNZWlsaVNlYXJjaFRpbWVPdXRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNZWlsaVNlYXJjaFRpbWVPdXRFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1laWxpU2VhcmNoVGltZU91dEVycm9yKG1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSAnTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3InO1xyXG4gICAgICAgIF90aGlzLnR5cGUgPSBfdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3I7XHJcbn0oRXJyb3IpKTtcblxuLyoqXHJcbiAqIFJlbW92ZXMgdW5kZWZpbmVkIGVudHJpZXMgZnJvbSBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEZyb21PYmplY3Qob2JqKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VyRW50cnkpIHtcclxuICAgICAgICB2YXIga2V5ID0gY3VyRW50cnlbMF0sIHZhbCA9IGN1ckVudHJ5WzFdO1xyXG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWw7XHJcbiAgICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9KTtcclxufVxyXG5mdW5jdGlvbiBzbGVlcChtcykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCBtcyk7IH0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFByb3RvY29sSWZOb3RQcmVzZW50KGhvc3QpIHtcclxuICAgIGlmICghKGhvc3Quc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSB8fCBob3N0LnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSkpIHtcclxuICAgICAgICByZXR1cm4gXCJodHRwOi8vXCIuY29uY2F0KGhvc3QpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhvc3Q7XHJcbn1cclxuZnVuY3Rpb24gYWRkVHJhaWxpbmdTbGFzaCh1cmwpIHtcclxuICAgIGlmICghdXJsLmVuZHNXaXRoKCcvJykpIHtcclxuICAgICAgICB1cmwgKz0gJy8nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVybDtcclxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RIb3N0VVJMKGhvc3QpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaG9zdCA9IGFkZFByb3RvY29sSWZOb3RQcmVzZW50KGhvc3QpO1xyXG4gICAgICAgIGhvc3QgPSBhZGRUcmFpbGluZ1NsYXNoKGhvc3QpO1xyXG4gICAgICAgIHJldHVybiBob3N0O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgTWVpbGlTZWFyY2hFcnJvcignVGhlIHByb3ZpZGVkIGhvc3QgaXMgbm90IHZhbGlkLicpO1xyXG4gICAgfVxyXG59XHJcbnZhciBIdHRwUmVxdWVzdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIdHRwUmVxdWVzdHMoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLmhlYWRlcnMgfHwge30pOyAvLyBhc3NpZ24gdG8gYXZvaWQgcmVmZXJlbmNpbmdcclxuICAgICAgICB0aGlzLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xyXG4gICAgICAgIGlmIChjb25maWcuYXBpS2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gXCJCZWFyZXIgXCIuY29uY2F0KGNvbmZpZy5hcGlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgaG9zdCA9IGNvbnN0cnVjdEhvc3RVUkwoY29uZmlnLmhvc3QpO1xyXG4gICAgICAgICAgICB0aGlzLnVybCA9IG5ldyBVUkwoaG9zdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBNZWlsaVNlYXJjaEVycm9yKCdUaGUgcHJvdmlkZWQgaG9zdCBpcyBub3QgdmFsaWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgSHR0cFJlcXVlc3RzLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IF9hLm1ldGhvZCwgdXJsID0gX2EudXJsLCBwYXJhbXMgPSBfYS5wYXJhbXMsIGJvZHkgPSBfYS5ib2R5LCBjb25maWcgPSBfYS5jb25maWc7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29uc3RydWN0VVJMLCBxdWVyeVBhcmFtc18xLCByZXNwb25zZSwgcGFyc2VkQm9keSwgcGFyc2VkSnNvbiwgZV8xLCBzdGFjaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0VVJMID0gbmV3IFVSTCh1cmwsIHRoaXMudXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXNfMSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiBwYXJhbXNbeF0gIT09IG51bGw7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcXVlcnlQYXJhbXNfMS5zZXQoeCwgcGFyYW1zW3hdKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RVUkwuc2VhcmNoID0gcXVlcnlQYXJhbXNfMS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgNCwgLCA1XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKGNvbnN0cnVjdFVSTC50b1N0cmluZygpLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29uZmlnKSwgeyBtZXRob2Q6IG1ldGhvZCwgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksIGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KSkudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBodHRwUmVzcG9uc2VFcnJvckhhbmRsZXIocmVzKTsgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLnRleHQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRCb2R5ID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSnNvbiA9IEpTT04ucGFyc2UocGFyc2VkQm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcGFyc2VkSnNvbl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBlXzEuc3RhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBFcnJvckhhbmRsZXIoZV8xLCBzdGFjaywgY29uc3RydWN0VVJMLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSHR0cFJlcXVlc3RzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIHBhcmFtcywgY29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIdHRwUmVxdWVzdHMucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIHBhcmFtcywgY29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBwYXJhbXMsIGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBwYXJhbXMsIGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSHR0cFJlcXVlc3RzO1xyXG59KCkpO1xuXG52YXIgVGFza0NsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRhc2tDbGllbnQoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5odHRwUmVxdWVzdCA9IG5ldyBIdHRwUmVxdWVzdHMoY29uZmlnKTtcclxuICAgIH1cclxuICAgIFRhc2tDbGllbnQucHJvdG90eXBlLmdldENsaWVudFRhc2sgPSBmdW5jdGlvbiAodWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcInRhc2tzL1wiLmNvbmNhdCh1aWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUYXNrQ2xpZW50LnByb3RvdHlwZS5nZXRDbGllbnRUYXNrcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwidGFza3NcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGFza0NsaWVudC5wcm90b3R5cGUuZ2V0SW5kZXhUYXNrID0gZnVuY3Rpb24gKGluZGV4VWlkLCB0YXNrSWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQoaW5kZXhVaWQsIFwiL3Rhc2tzL1wiKS5jb25jYXQodGFza0lkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGFza0NsaWVudC5wcm90b3R5cGUuZ2V0SW5kZXhUYXNrcyA9IGZ1bmN0aW9uIChpbmRleFVpZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdChpbmRleFVpZCwgXCIvdGFza3NcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FpdCBmb3IgYSB0YXNrIHRvIGJlIHByb2Nlc3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdWlkIFRhc2sgaWRlbnRpZmllclxyXG4gICAgICogQHBhcmFtIHtXYWl0T3B0aW9uc30gb3B0aW9ucyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VGFzaz59IFByb21pc2UgcmV0dXJuaW5nIGEgdGFzayBhZnRlciBpdCBoYXMgYmVlbiBwcm9jZXNzZWRcclxuICAgICAqL1xyXG4gICAgVGFza0NsaWVudC5wcm90b3R5cGUud2FpdEZvckNsaWVudFRhc2sgPSBmdW5jdGlvbiAodGFza0lkLCBfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLnRpbWVPdXRNcywgdGltZU91dE1zID0gX2MgPT09IHZvaWQgMCA/IDUwMDAgOiBfYywgX2QgPSBfYi5pbnRlcnZhbE1zLCBpbnRlcnZhbE1zID0gX2QgPT09IHZvaWQgMCA/IDUwIDogX2Q7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRpbmdUaW1lLCByZXNwb25zZTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRpbmdUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoRGF0ZS5ub3coKSAtIHN0YXJ0aW5nVGltZSA8IHRpbWVPdXRNcykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldENsaWVudFRhc2sodGFza0lkKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9lLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFbXCJlbnF1ZXVlZFwiIC8qIFRBU0tfRU5RVUVVRUQgKi8sIFwicHJvY2Vzc2luZ1wiIC8qIFRBU0tfUFJPQ0VTU0lORyAqL10uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNsZWVwKGludGVydmFsTXMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiB0aHJvdyBuZXcgTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3IoXCJ0aW1lb3V0IG9mIFwiLmNvbmNhdCh0aW1lT3V0TXMsIFwibXMgaGFzIGV4Y2VlZGVkIG9uIHByb2Nlc3MgXCIpLmNvbmNhdCh0YXNrSWQsIFwiIHdoZW4gd2FpdGluZyBhIHRhc2sgdG8gYmUgcmVzb2x2ZWQuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0cyBmb3IgbXVsdGlwbGUgdGFza3MgdG8gYmUgcHJvY2Vzc2VkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhc2tJZHMgVGFza3MgaWRlbnRpZmllciBsaXN0XHJcbiAgICAgKiBAcGFyYW0ge1dhaXRPcHRpb25zfSBvcHRpb25zIFdhaXQgb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0PFRhc2tbXT4+fSBQcm9taXNlIHJldHVybmluZyBhIGxpc3Qgb2YgdGFza3MgYWZ0ZXIgdGhleSBoYXZlIGJlZW4gcHJvY2Vzc2VkXHJcbiAgICAgKi9cclxuICAgIFRhc2tDbGllbnQucHJvdG90eXBlLndhaXRGb3JDbGllbnRUYXNrcyA9IGZ1bmN0aW9uICh0YXNrSWRzLCBfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLnRpbWVPdXRNcywgdGltZU91dE1zID0gX2MgPT09IHZvaWQgMCA/IDUwMDAgOiBfYywgX2QgPSBfYi5pbnRlcnZhbE1zLCBpbnRlcnZhbE1zID0gX2QgPT09IHZvaWQgMCA/IDUwIDogX2Q7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGFza3MsIF9pLCB0YXNrSWRzXzEsIHRhc2tJZCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCB0YXNrSWRzXzEgPSB0YXNrSWRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IHRhc2tJZHNfMS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza0lkID0gdGFza0lkc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy53YWl0Rm9yQ2xpZW50VGFzayh0YXNrSWQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lT3V0TXM6IHRpbWVPdXRNcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbE1zOiBpbnRlcnZhbE1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Uuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHRhc2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCB7IHJlc3VsdHM6IHRhc2tzIH1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdhaXRzIGZvciBhIHRhc2sgdG8gYmUgcHJvY2Vzc2VkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhc2tJZCBUYXNrIGlkZW50aWZpZXJcclxuICAgICAqIEBwYXJhbSB7V2FpdE9wdGlvbnN9IG9wdGlvbnMgV2FpdCBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUYXNrPn0gUHJvbWlzZSByZXR1cm5pbmcgYSB0YXNrIGFmdGVyIGl0IGhhcyBiZWVuIHByb2Nlc3NlZFxyXG4gICAgICovXHJcbiAgICBUYXNrQ2xpZW50LnByb3RvdHlwZS53YWl0Rm9ySW5kZXhUYXNrID0gZnVuY3Rpb24gKGluZGV4VWlkLCB0YXNrSWQsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IudGltZU91dE1zLCB0aW1lT3V0TXMgPSBfYyA9PT0gdm9pZCAwID8gNTAwMCA6IF9jLCBfZCA9IF9iLmludGVydmFsTXMsIGludGVydmFsTXMgPSBfZCA9PT0gdm9pZCAwID8gNTAgOiBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydGluZ1RpbWUsIHJlc3BvbnNlO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydGluZ1RpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShEYXRlLm5vdygpIC0gc3RhcnRpbmdUaW1lIDwgdGltZU91dE1zKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0SW5kZXhUYXNrKGluZGV4VWlkLCB0YXNrSWQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Uuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVtcImVucXVldWVkXCIgLyogVEFTS19FTlFVRVVFRCAqLywgXCJwcm9jZXNzaW5nXCIgLyogVEFTS19QUk9DRVNTSU5HICovXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2xlZXAoaW50ZXJ2YWxNcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Uuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHRocm93IG5ldyBNZWlsaVNlYXJjaFRpbWVPdXRFcnJvcihcInRpbWVvdXQgb2YgXCIuY29uY2F0KHRpbWVPdXRNcywgXCJtcyBoYXMgZXhjZWVkZWQgb24gcHJvY2VzcyBcIikuY29uY2F0KHRhc2tJZCwgXCIgd2hlbiB3YWl0aW5nIGZvciBwZW5kaW5nIHVwZGF0ZSB0byByZXNvbHZlLlwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUYXNrQ2xpZW50O1xyXG59KCkpO1xuXG4vKlxyXG4gKiBCdW5kbGU6IE1laWxpU2VhcmNoIC8gSW5kZXhlc1xyXG4gKiBQcm9qZWN0OiBNZWlsaVNlYXJjaCAtIEphdmFzY3JpcHQgQVBJXHJcbiAqIEF1dGhvcjogUXVlbnRpbiBkZSBRdWVsZW4gPHF1ZW50aW5AbWVpbGlzZWFyY2guY29tPlxyXG4gKiBDb3B5cmlnaHQ6IDIwMTksIE1laWxpU2VhcmNoXHJcbiAqL1xyXG52YXIgSW5kZXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Q29uZmlnfSBjb25maWcgUmVxdWVzdCBjb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVUlEIG9mIHRoZSBpbmRleFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlLZXk/IFByaW1hcnkgS2V5IG9mIHRoZSBpbmRleFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBJbmRleChjb25maWcsIHVpZCwgcHJpbWFyeUtleSkge1xyXG4gICAgICAgIHRoaXMudWlkID0gdWlkO1xyXG4gICAgICAgIHRoaXMucHJpbWFyeUtleSA9IHByaW1hcnlLZXk7XHJcbiAgICAgICAgdGhpcy5odHRwUmVxdWVzdCA9IG5ldyBIdHRwUmVxdWVzdHMoY29uZmlnKTtcclxuICAgICAgICB0aGlzLnRhc2tzID0gbmV3IFRhc2tDbGllbnQoY29uZmlnKTtcclxuICAgIH1cclxuICAgIC8vL1xyXG4gICAgLy8vIFNFQVJDSFxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaCBmb3IgZG9jdW1lbnRzIGludG8gYW4gaW5kZXhcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBzZWFyY2hcclxuICAgICAqIEB0ZW1wbGF0ZSBUXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHF1ZXJ5PyBRdWVyeSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7U2VhcmNoUGFyYW1zfSBvcHRpb25zPyBTZWFyY2ggb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsPFJlcXVlc3Q+fSBjb25maWc/IEFkZGl0aW9uYWwgcmVxdWVzdCBjb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlYXJjaFJlc3BvbnNlPFQ+Pn0gUHJvbWlzZSBjb250YWluaW5nIHRoZSBzZWFyY2ggcmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChxdWVyeSwgb3B0aW9ucywgY29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZWFyY2hcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwsIHJlbW92ZVVuZGVmaW5lZEZyb21PYmplY3QoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHE6IHF1ZXJ5IH0pKSwgdW5kZWZpbmVkLCBjb25maWcpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaCBmb3IgZG9jdW1lbnRzIGludG8gYW4gaW5kZXggdXNpbmcgdGhlIEdFVCBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBzZWFyY2hcclxuICAgICAqIEB0ZW1wbGF0ZSBUXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHF1ZXJ5PyBRdWVyeSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7U2VhcmNoUGFyYW1zfSBvcHRpb25zPyBTZWFyY2ggb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsPFJlcXVlc3Q+fSBjb25maWc/IEFkZGl0aW9uYWwgcmVxdWVzdCBjb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlYXJjaFJlc3BvbnNlPFQ+Pn0gUHJvbWlzZSBjb250YWluaW5nIHRoZSBzZWFyY2ggcmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnNlYXJjaEdldCA9IGZ1bmN0aW9uIChxdWVyeSwgb3B0aW9ucywgY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHBhcnNlRmlsdGVyLCBnZXRQYXJhbXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2YubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NlYXJjaFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWVpbGlTZWFyY2hFcnJvcignVGhlIGZpbHRlciBxdWVyeSBwYXJhbWV0ZXIgc2hvdWxkIGJlIGluIHN0cmluZyBmb3JtYXQgd2hlbiB1c2luZyBzZWFyY2hHZXQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7IHE6IHF1ZXJ5IH0sIG9wdGlvbnMpLCB7IGZpbHRlcjogcGFyc2VGaWx0ZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZpbHRlciksIHNvcnQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euam9pbignLCcpLCBmYWNldHNEaXN0cmlidXRpb246IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWNldHNEaXN0cmlidXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5qb2luKCcsJyksIGF0dHJpYnV0ZXNUb1JldHJpZXZlOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0cmlidXRlc1RvUmV0cmlldmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5qb2luKCcsJyksIGF0dHJpYnV0ZXNUb0Nyb3A6IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzVG9Dcm9wKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quam9pbignLCcpLCBhdHRyaWJ1dGVzVG9IaWdobGlnaHQ6IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzVG9IaWdobGlnaHQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5qb2luKCcsJykgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCwgcmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdChnZXRQYXJhbXMpLCBjb25maWcpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfZi5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBJTkRFWFxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCBpbmRleCBpbmZvcm1hdGlvbi5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXRSYXdJbmZvXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleFJlc3BvbnNlPn0gUHJvbWlzZSBjb250YWluaW5nIGluZGV4IGluZm9ybWF0aW9uXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRSYXdJbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgcmVzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbWFyeUtleSA9IHJlcy5wcmltYXJ5S2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaCBhbmQgdXBkYXRlIEluZGV4IGluZm9ybWF0aW9uLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGZldGNoSW5mb1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dGhpcz59IFByb21pc2UgdG8gdGhlIGN1cnJlbnQgSW5kZXggb2JqZWN0IHdpdGggdXBkYXRlZCBpbmZvcm1hdGlvblxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZmV0Y2hJbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRSYXdJbmZvKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpc107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IFByaW1hcnkgS2V5LlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGZldGNoUHJpbWFyeUtleVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPn0gUHJvbWlzZSBjb250YWluaW5nIHRoZSBQcmltYXJ5IEtleSBvZiB0aGUgaW5kZXhcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmZldGNoUHJpbWFyeUtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFJhd0luZm8oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5wcmltYXJ5S2V5ID0gKF9iLnNlbnQoKSkucHJpbWFyeUtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMucHJpbWFyeUtleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluZGV4LlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIEluZGV4XHJcbiAgICAgKiBAcGFyYW0ge0luZGV4T3B0aW9uc30gb3B0aW9ucyBJbmRleCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge0NvbmZpZ30gY29uZmlnIFJlcXVlc3QgY29uZmlndXJhdGlvbiBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleDxUPj59IE5ld2x5IGNyZWF0ZWQgSW5kZXggb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIEluZGV4LmNyZWF0ZSA9IGZ1bmN0aW9uICh1aWQsIG9wdGlvbnMsIGNvbmZpZykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCByZXE7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlc1wiO1xyXG4gICAgICAgICAgICAgICAgcmVxID0gbmV3IEh0dHBSZXF1ZXN0cyhjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlcS5wb3N0KHVybCwgX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHVpZDogdWlkIH0pKV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGFuIGluZGV4LlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIHtJbmRleE9wdGlvbnN9IGRhdGEgRGF0YSB0byB1cGRhdGVcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHRoaXM+fSBQcm9taXNlIHRvIHRoZSBjdXJyZW50IEluZGV4IG9iamVjdCB3aXRoIHVwZGF0ZWQgaW5mb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wdXQodXJsLCBkYXRhKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgYW4gaW5kZXguXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZGVsZXRlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGluZGV4IGlzIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIFRBU0tTXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGFsbCB0aGUgaW5kZXggdGFza3MuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4ZXNcclxuICAgICAqIEBtZXRob2QgZ2V0VGFza3NcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ8VGFza1tdPj59IC0gUHJvbWlzZSBjb250YWluaW5nIGFsbCB0YXNrc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0VGFza3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmdldEluZGV4VGFza3ModGhpcy51aWQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvbmUgdGFzayBvZiB0aGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4ZXNcclxuICAgICAqIEBtZXRob2QgZ2V0VGFza1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhc2tJZCAtIFRhc2sgaWRlbnRpZmllclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRhc2s+fSAtIFByb21pc2UgY29udGFpbmluZyBhIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldFRhc2sgPSBmdW5jdGlvbiAodGFza0lkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmdldEluZGV4VGFzayh0aGlzLnVpZCwgdGFza0lkKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0IGZvciBhIGJhdGNoIG9mIGFuIGluZGV4IHRhc2tzIHRvIGJlIHByb2Nlc3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhlc1xyXG4gICAgICogQG1ldGhvZCB3YWl0Rm9yVGFza3NcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRhc2tJZHMgLSBUYXNrcyBpZGVudGlmaWVyXHJcbiAgICAgKiBAcGFyYW0ge1dhaXRPcHRpb25zfSB3YWl0T3B0aW9ucyAtIE9wdGlvbnMgb24gdGltZW91dCBhbmQgaW50ZXJ2YWxcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ8VGFza1tdPj59IC0gUHJvbWlzZSBjb250YWluaW5nIGFuIGFycmF5IG9mIHRhc2tzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS53YWl0Rm9yVGFza3MgPSBmdW5jdGlvbiAodGFza0lkcywgX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi50aW1lT3V0TXMsIHRpbWVPdXRNcyA9IF9jID09PSB2b2lkIDAgPyA1MDAwIDogX2MsIF9kID0gX2IuaW50ZXJ2YWxNcywgaW50ZXJ2YWxNcyA9IF9kID09PSB2b2lkIDAgPyA1MCA6IF9kO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy50YXNrcy53YWl0Rm9yQ2xpZW50VGFza3ModGFza0lkcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZU91dE1zOiB0aW1lT3V0TXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbE1zOiBpbnRlcnZhbE1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfZS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdhaXQgZm9yIGFuIGluZGV4IHRhc2sgdG8gYmUgcHJvY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleGVzXHJcbiAgICAgKiBAbWV0aG9kIHdhaXRGb3JUYXNrXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFza0lkIC0gVGFzayBpZGVudGlmaWVyXHJcbiAgICAgKiBAcGFyYW0ge1dhaXRPcHRpb25zfSB3YWl0T3B0aW9ucyAtIE9wdGlvbnMgb24gdGltZW91dCBhbmQgaW50ZXJ2YWxcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUYXNrPn0gLSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgdGFza3NcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLndhaXRGb3JUYXNrID0gZnVuY3Rpb24gKHRhc2tJZCwgX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi50aW1lT3V0TXMsIHRpbWVPdXRNcyA9IF9jID09PSB2b2lkIDAgPyA1MDAwIDogX2MsIF9kID0gX2IuaW50ZXJ2YWxNcywgaW50ZXJ2YWxNcyA9IF9kID09PSB2b2lkIDAgPyA1MCA6IF9kO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy50YXNrcy53YWl0Rm9yQ2xpZW50VGFzayh0YXNrSWQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPdXRNczogdGltZU91dE1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxNc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Uuc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU1RBVFNcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQgc3RhdHMgb2YgYW4gaW5kZXhcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXRTdGF0c1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW5kZXhTdGF0cz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgd2l0aCBzdGF0cyBvZiB0aGUgaW5kZXhcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc3RhdHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIERPQ1VNRU5UU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIGdldCBkb2N1bWVudHMgb2YgYW4gaW5kZXhcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXREb2N1bWVudHNcclxuICAgICAqIEB0ZW1wbGF0ZSBUXHJcbiAgICAgKiBAcGFyYW0ge0dldERvY3VtZW50c1BhcmFtczxUPn0gb3B0aW9ucz8gT3B0aW9ucyB0byBicm93c2UgdGhlIGRvY3VtZW50c1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0RG9jdW1lbnRzUmVzcG9uc2U8VD4+fSBQcm9taXNlIGNvbnRhaW5pbmcgRG9jdW1lbnQgcmVzcG9uc2VzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXREb2N1bWVudHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgYXR0cjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvZG9jdW1lbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5hdHRyaWJ1dGVzVG9SZXRyaWV2ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBvcHRpb25zLmF0dHJpYnV0ZXNUb1JldHJpZXZlLmpvaW4oJywnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgKGF0dHIgIT09IHVuZGVmaW5lZCA/IHsgYXR0cmlidXRlc1RvUmV0cmlldmU6IGF0dHIgfSA6IHt9KSkpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvbmUgZG9jdW1lbnRcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXREb2N1bWVudFxyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBkb2N1bWVudElkIERvY3VtZW50IElEXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEb2N1bWVudDxUPj59IFByb21pc2UgY29udGFpbmluZyBEb2N1bWVudCByZXNwb25zZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jdW1lbnRJZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvZG9jdW1lbnRzL1wiKS5jb25jYXQoZG9jdW1lbnRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIG9yIHJlcGxhY2UgbXVsdGlwbGVzIGRvY3VtZW50cyB0byBhbiBpbmRleFxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGFkZERvY3VtZW50c1xyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8RG9jdW1lbnQ8VD4+fSBkb2N1bWVudHMgQXJyYXkgb2YgRG9jdW1lbnQgb2JqZWN0cyB0byBhZGQvcmVwbGFjZVxyXG4gICAgICogQHBhcmFtIHtBZGREb2N1bWVudFBhcmFtc30gb3B0aW9ucz8gUXVlcnkgcGFyYW1ldGVyc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5hZGREb2N1bWVudHMgPSBmdW5jdGlvbiAoZG9jdW1lbnRzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwsIGRvY3VtZW50cywgb3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIG9yIHJlcGxhY2UgbXVsdGlwbGVzIGRvY3VtZW50cyB0byBhbiBpbmRleCBpbiBiYXRjaGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgYWRkRG9jdW1lbnRzSW5CYXRjaGVzXHJcbiAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICogQHBhcmFtIHtBcnJheTxEb2N1bWVudDxUPj59IGRvY3VtZW50cyBBcnJheSBvZiBEb2N1bWVudCBvYmplY3RzIHRvIGFkZC9yZXBsYWNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmF0Y2hTaXplIFNpemUgb2YgdGhlIGJhdGNoXHJcbiAgICAgKiBAcGFyYW0ge0FkZERvY3VtZW50UGFyYW1zfSBvcHRpb25zPyBRdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2tzPn0gUHJvbWlzZSBjb250YWluaW5nIGFycmF5IG9mIGVucXVldWVkIHVwZGF0ZSBvYmplY3RzIGZvciBlYWNoIGJhdGNoXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5hZGREb2N1bWVudHNJbkJhdGNoZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnRzLCBiYXRjaFNpemUsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoYmF0Y2hTaXplID09PSB2b2lkIDApIHsgYmF0Y2hTaXplID0gMTAwMDsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVwZGF0ZXMsIGksIF9hLCBfYjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IGRvY3VtZW50cy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSB1cGRhdGVzKS5wdXNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmFkZERvY3VtZW50cyhkb2N1bWVudHMuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSksIG9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gYmF0Y2hTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCB1cGRhdGVzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgb3IgdXBkYXRlIG11bHRpcGxlcyBkb2N1bWVudHMgdG8gYW4gaW5kZXhcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVEb2N1bWVudHNcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8RG9jdW1lbnQ8UGFydGlhbDxUPj4+fSBkb2N1bWVudHMgQXJyYXkgb2YgRG9jdW1lbnQgb2JqZWN0cyB0byBhZGQvdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0ge0FkZERvY3VtZW50UGFyYW1zfSBvcHRpb25zPyBRdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50cyA9IGZ1bmN0aW9uIChkb2N1bWVudHMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL2RvY3VtZW50c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wdXQodXJsLCBkb2N1bWVudHMsIG9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBvciB1cGRhdGUgbXVsdGlwbGVzIGRvY3VtZW50cyB0byBhbiBpbmRleCBpbiBiYXRjaGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgdXBkYXRlRG9jdW1lbnRzXHJcbiAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICogQHBhcmFtIHtBcnJheTxEb2N1bWVudDxUPj59IGRvY3VtZW50cyBBcnJheSBvZiBEb2N1bWVudCBvYmplY3RzIHRvIGFkZC91cGRhdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXRjaFNpemUgU2l6ZSBvZiB0aGUgYmF0Y2hcclxuICAgICAqIEBwYXJhbSB7QWRkRG9jdW1lbnRQYXJhbXN9IG9wdGlvbnM/IFF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFza3M+fSBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgZW5xdWV1ZWQgdXBkYXRlIG9iamVjdHMgZm9yIGVhY2ggYmF0Y2hcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50c0luQmF0Y2hlcyA9IGZ1bmN0aW9uIChkb2N1bWVudHMsIGJhdGNoU2l6ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChiYXRjaFNpemUgPT09IHZvaWQgMCkgeyBiYXRjaFNpemUgPSAxMDAwOyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXBkYXRlcywgaSwgX2EsIF9iO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgZG9jdW1lbnRzLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IHVwZGF0ZXMpLnB1c2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudXBkYXRlRG9jdW1lbnRzKGRvY3VtZW50cy5zbGljZShpLCBpICsgYmF0Y2hTaXplKSwgb3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBiYXRjaFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVwZGF0ZXNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBvbmUgZG9jdW1lbnRcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBkZWxldGVEb2N1bWVudFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGRvY3VtZW50SWQgSWQgb2YgRG9jdW1lbnQgdG8gZGVsZXRlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB0YXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5kZWxldGVEb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudElkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHMvXCIpLmNvbmNhdChkb2N1bWVudElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBtdWx0aXBsZXMgZG9jdW1lbnRzIG9mIGFuIGluZGV4XHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZGVsZXRlRG9jdW1lbnRzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgbnVtYmVyW119IGRvY3VtZW50c0lkcyBBcnJheSBvZiBEb2N1bWVudCBJZHMgdG8gZGVsZXRlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB0YXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5kZWxldGVEb2N1bWVudHMgPSBmdW5jdGlvbiAoZG9jdW1lbnRzSWRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHMvZGVsZXRlLWJhdGNoXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBkb2N1bWVudHNJZHMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBhbGwgZG9jdW1lbnRzIG9mIGFuIGluZGV4XHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZGVsZXRlQWxsRG9jdW1lbnRzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB0YXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5kZWxldGVBbGxEb2N1bWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU0VUVElOR1NcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBhbGwgc2V0dGluZ3NcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXRTZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2V0dGluZ3M+fSBQcm9taXNlIGNvbnRhaW5pbmcgU2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhbGwgc2V0dGluZ3NcclxuICAgICAqIEFueSBwYXJhbWV0ZXJzIG5vdCBwcm92aWRlZCB3aWxsIGJlIGxlZnQgdW5jaGFuZ2VkLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0ge1NldHRpbmdzfSBzZXR0aW5ncyBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHdpdGggdGhlaXIgdXBkYXRlZCB2YWx1ZXNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVNldHRpbmdzID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5nc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgc2V0dGluZ3MpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHNldHRpbmdzLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHJlc2V0U2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnJlc2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5nc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBTWU5PTllNU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBhbGwgc3lub255bXNcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXRTeW5vbnltc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiBzeW5vbnltIG1hcHBpbmdzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRTeW5vbnltcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3N5bm9ueW1zXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgbGlzdCBvZiBzeW5vbnltcy4gT3ZlcndyaXRlIHRoZSBvbGQgbGlzdC5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVTeW5vbnltc1xyXG4gICAgICogQHBhcmFtIHtTeW5vbnltc30gc3lub255bXMgTWFwcGluZyBvZiBzeW5vbnltcyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd29yZHNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVN5bm9ueW1zID0gZnVuY3Rpb24gKHN5bm9ueW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zeW5vbnltc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgc3lub255bXMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBzeW5vbnltIGxpc3QgdG8gYmUgZW1wdHkgYWdhaW5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCByZXNldFN5bm9ueW1zXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB0YXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldFN5bm9ueW1zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc3lub255bXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU1RPUCBXT1JEU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBhbGwgc3RvcC13b3Jkc1xyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGdldFN0b3BXb3Jkc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygc3RvcC13b3Jkc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0U3RvcFdvcmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc3RvcC13b3Jkc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGxpc3Qgb2Ygc3RvcC13b3Jkcy4gT3ZlcndyaXRlIHRoZSBvbGQgbGlzdC5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVTdG9wV29yZHNcclxuICAgICAqIEBwYXJhbSB7U3RvcFdvcmRzfSBzdG9wV29yZHMgQXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGNvbnRhaW5zIHRoZSBzdG9wLXdvcmRzLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVTdG9wV29yZHMgPSBmdW5jdGlvbiAoc3RvcFdvcmRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zdG9wLXdvcmRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBzdG9wV29yZHMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBzdG9wLXdvcmRzIGxpc3QgdG8gYmUgZW1wdHkgYWdhaW5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCByZXNldFN0b3BXb3Jkc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldFN0b3BXb3JkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3N0b3Atd29yZHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gUkFOS0lORyBSVUxFU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBhbGwgcmFua2luZy1ydWxlc1xyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGdldFJhbmtpbmdSdWxlc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW119IFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiByYW5raW5nLXJ1bGVzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRSYW5raW5nUnVsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9yYW5raW5nLXJ1bGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgbGlzdCBvZiByYW5raW5nLXJ1bGVzLiBPdmVyd3JpdGUgdGhlIG9sZCBsaXN0LlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVJhbmtpbmdSdWxlc1xyXG4gICAgICogQHBhcmFtIHtSYW5raW5nUnVsZXN9IHJhbmtpbmdSdWxlcyBBcnJheSB0aGF0IGNvbnRhaW4gcmFua2luZyBydWxlcyBzb3J0ZWQgYnkgb3JkZXIgb2YgaW1wb3J0YW5jZS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlUmFua2luZ1J1bGVzID0gZnVuY3Rpb24gKHJhbmtpbmdSdWxlcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvcmFua2luZy1ydWxlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgcmFua2luZ1J1bGVzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgcmFua2luZyBydWxlcyBsaXN0IHRvIGl0cyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgcmVzZXRSYW5raW5nUnVsZXNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUucmVzZXRSYW5raW5nUnVsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9yYW5raW5nLXJ1bGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIERJU1RJTkNUIEFUVFJJQlVURVxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGlzdGluY3QtYXR0cmlidXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZ2V0RGlzdGluY3RBdHRyaWJ1dGVcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZyB8IG51bGw+fSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIGRpc3RpbmN0LWF0dHJpYnV0ZSBvZiB0aGUgaW5kZXhcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldERpc3RpbmN0QXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZGlzdGluY3QtYXR0cmlidXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgZGlzdGluY3QtYXR0cmlidXRlLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZURpc3RpbmN0QXR0cmlidXRlXHJcbiAgICAgKiBAcGFyYW0ge0Rpc3RpbmN0QXR0cmlidXRlfSBkaXN0aW5jdEF0dHJpYnV0ZSBGaWVsZCBuYW1lIG9mIHRoZSBkaXN0aW5jdC1hdHRyaWJ1dGVcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlRGlzdGluY3RBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZGlzdGluY3RBdHRyaWJ1dGUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2Rpc3RpbmN0LWF0dHJpYnV0ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgZGlzdGluY3RBdHRyaWJ1dGUpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBkaXN0aW5jdC1hdHRyaWJ1dGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgcmVzZXREaXN0aW5jdEF0dHJpYnV0ZVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldERpc3RpbmN0QXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZGlzdGluY3QtYXR0cmlidXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIEZJTFRFUkFCTEUgQVRUUklCVVRFU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZmlsdGVyYWJsZS1hdHRyaWJ1dGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZ2V0RmlsdGVyYWJsZUF0dHJpYnV0ZXNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0gUHJvbWlzZSBjb250YWluaW5nIGFuIGFycmF5IG9mIGZpbHRlcmFibGUtYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0RmlsdGVyYWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9maWx0ZXJhYmxlLWF0dHJpYnV0ZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBmaWx0ZXJhYmxlLWF0dHJpYnV0ZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgdXBkYXRlRmlsdGVyYWJsZUF0dHJpYnV0ZXNcclxuICAgICAqIEBwYXJhbSB7RmlsdGVyYWJsZUF0dHJpYnV0ZXN9IGZpbHRlcmFibGVBdHRyaWJ1dGVzIEFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyB0aGUgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIGZpbHRlcnMgYXQgcXVlcnkgdGltZVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVGaWx0ZXJhYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChmaWx0ZXJhYmxlQXR0cmlidXRlcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZmlsdGVyYWJsZS1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBmaWx0ZXJhYmxlQXR0cmlidXRlcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGZpbHRlcmFibGUtYXR0cmlidXRlcy5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCByZXNldEZpbHRlcmFibGVBdHRyaWJ1dGVzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnJlc2V0RmlsdGVyYWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9maWx0ZXJhYmxlLWF0dHJpYnV0ZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU09SVEFCTEUgQVRUUklCVVRFU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc29ydGFibGUtYXR0cmlidXRlc1xyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGdldFNvcnRhYmxlQXR0cmlidXRlc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygc29ydGFibGUtYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0U29ydGFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc29ydGFibGUtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIHNvcnRhYmxlLWF0dHJpYnV0ZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgdXBkYXRlU29ydGFibGVBdHRyaWJ1dGVzXHJcbiAgICAgKiBAcGFyYW0ge1NvcnRhYmxlQXR0cmlidXRlc30gc29ydGFibGVBdHRyaWJ1dGVzIEFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyB0aGUgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIHRvIHNvcnQgc2VhcmNoIHJlc3VsdHMgYXQgcXVlcnkgdGltZVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlU29ydGFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHNvcnRhYmxlQXR0cmlidXRlcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc29ydGFibGUtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgc29ydGFibGVBdHRyaWJ1dGVzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgc29ydGFibGUtYXR0cmlidXRlcy5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCByZXNldFNvcnRhYmxlQXR0cmlidXRlc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUucmVzZXRTb3J0YWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zb3J0YWJsZS1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIFNFQVJDSEFCTEUgQVRUUklCVVRFXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzZWFyY2hhYmxlLWF0dHJpYnV0ZXNcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXRTZWFyY2hhYmxlQXR0cmlidXRlc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygc2VhcmNoYWJsZS1hdHRyaWJ1dGVzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRTZWFyY2hhYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3NlYXJjaGFibGUtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIHNlYXJjaGFibGUtYXR0cmlidXRlcy5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVTZWFyY2hhYmxlQXR0cmlidXRlc1xyXG4gICAgICogQHBhcmFtIHtTZWFyY2hhYmxlQXR0cmlidXRlc30gc2VhcmNoYWJsZUF0dHJpYnV0ZXMgQXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGNvbnRhaW5zIHNlYXJjaGFibGUgYXR0cmlidXRlcyBzb3J0ZWQgYnkgb3JkZXIgb2YgaW1wb3J0YW5jZShtb3N0IHRvIGxlYXN0IGltcG9ydGFudClcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVNlYXJjaGFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHNlYXJjaGFibGVBdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zZWFyY2hhYmxlLWF0dHJpYnV0ZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwsIHNlYXJjaGFibGVBdHRyaWJ1dGVzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgc2VhcmNoYWJsZS1hdHRyaWJ1dGVzLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHJlc2V0U2VhcmNoYWJsZUF0dHJpYnV0ZXNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnJlc2V0U2VhcmNoYWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zZWFyY2hhYmxlLWF0dHJpYnV0ZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gRElTUExBWUVEIEFUVFJJQlVURVxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGlzcGxheWVkLWF0dHJpYnV0ZXNcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXREaXNwbGF5ZWRBdHRyaWJ1dGVzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiBkaXNwbGF5ZWQtYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0RGlzcGxheWVkQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2Rpc3BsYXllZC1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgZGlzcGxheWVkLWF0dHJpYnV0ZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgdXBkYXRlRGlzcGxheWVkQXR0cmlidXRlc1xyXG4gICAgICogQHBhcmFtIHtEaXNwbGF5ZWRBdHRyaWJ1dGVzfSBkaXNwbGF5ZWRBdHRyaWJ1dGVzIEFycmF5IG9mIHN0cmluZ3MgdGhhdCBjb250YWlucyBhdHRyaWJ1dGVzIG9mIGFuIGluZGV4IHRvIGRpc3BsYXlcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlRGlzcGxheWVkQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChkaXNwbGF5ZWRBdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9kaXNwbGF5ZWQtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgZGlzcGxheWVkQXR0cmlidXRlcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGRpc3BsYXllZC1hdHRyaWJ1dGVzLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHJlc2V0RGlzcGxheWVkQXR0cmlidXRlc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldERpc3BsYXllZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9kaXNwbGF5ZWQtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBUWVBPIFRPTEVSQU5DRVxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdHlwbyB0b2xlcmFuY2Ugc2V0dGluZ3MuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZ2V0VHlwb1RvbGVyYW5jZVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIHR5cG8gdG9sZXJhbmNlIHNldHRpbmdzLlxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0VHlwb1RvbGVyYW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3R5cG8tdG9sZXJhbmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgdHlwbyB0b2xlcmFuY2Ugc2V0dGluZ3MuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgdXBkYXRlVHlwb1RvbGVyYW5jZVxyXG4gICAgICogQHBhcmFtIHtUeXBvVG9sZXJhbmNlfSB0eXBvVG9sZXJhbmNlIE9iamVjdCBjb250YWluaW5nIHRoZSBjdXN0b20gdHlwbyB0b2xlcmFuY2Ugc2V0dGluZ3MuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVR5cG9Ub2xlcmFuY2UgPSBmdW5jdGlvbiAodHlwb1RvbGVyYW5jZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvdHlwby10b2xlcmFuY2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwsIHR5cG9Ub2xlcmFuY2UpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSB0eXBvIHRvbGVyYW5jZSBzZXR0aW5ncy5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCByZXNldFR5cG9Ub2xlcmFuY2VcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUucmVzZXRUeXBvVG9sZXJhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvdHlwby10b2xlcmFuY2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEluZGV4O1xyXG59KCkpO1xuXG4vKlxyXG4gKiBCdW5kbGU6IE1laWxpU2VhcmNoXHJcbiAqIFByb2plY3Q6IE1laWxpU2VhcmNoIC0gSmF2YXNjcmlwdCBBUElcclxuICogQXV0aG9yOiBRdWVudGluIGRlIFF1ZWxlbiA8cXVlbnRpbkBtZWlsaXNlYXJjaC5jb20+XHJcbiAqIENvcHlyaWdodDogMjAxOSwgTWVpbGlTZWFyY2hcclxuICovXHJcbnZhciBDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IE1laWxpU2VhcmNoIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0NvbmZpZ30gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENsaWVudChjb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0ID0gbmV3IEh0dHBSZXF1ZXN0cyhjb25maWcpO1xyXG4gICAgICAgIHRoaXMudGFza3MgPSBuZXcgVGFza0NsaWVudChjb25maWcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYW4gSW5kZXggaW5zdGFuY2VcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBpbmRleFxyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmRleFVpZCBUaGUgaW5kZXggVUlEXHJcbiAgICAgKiBAcmV0dXJucyB7SW5kZXg8VD59IEluc3RhbmNlIG9mIEluZGV4XHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbiAoaW5kZXhVaWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4KHRoaXMuY29uZmlnLCBpbmRleFVpZCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYXRoZXIgaW5mb3JtYXRpb24gYWJvdXQgYW4gaW5kZXggYnkgY2FsbGluZyBNZWlsaVNlYXJjaCBhbmRcclxuICAgICAqIHJldHVybiBhbiBJbmRleCBpbnN0YW5jZSB3aXRoIHRoZSBnYXRoZXJlZCBpbmZvcm1hdGlvblxyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGdldEluZGV4XHJcbiAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluZGV4VWlkIFRoZSBpbmRleCBVSURcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEluZGV4PFQ+Pn0gUHJvbWlzZSByZXR1cm5pbmcgSW5kZXggaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleFVpZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBJbmRleCh0aGlzLmNvbmZpZywgaW5kZXhVaWQpLmZldGNoSW5mbygpXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYXRoZXIgaW5mb3JtYXRpb24gYWJvdXQgYW4gaW5kZXggYnkgY2FsbGluZyBNZWlsaVNlYXJjaCBhbmRcclxuICAgICAqIHJldHVybiB0aGUgcmF3IEpTT04gcmVzcG9uc2VcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZXRSYXdJbmRleFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluZGV4VWlkIFRoZSBpbmRleCBVSURcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEluZGV4UmVzcG9uc2U+fSBQcm9taXNlIHJldHVybmluZyBpbmRleCBpbmZvcm1hdGlvblxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmdldFJhd0luZGV4ID0gZnVuY3Rpb24gKGluZGV4VWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IEluZGV4KHRoaXMuY29uZmlnLCBpbmRleFVpZCkuZ2V0UmF3SW5mbygpXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIHRoZSBpbmRleGVzIGFzIEluZGV4IGluc3RhbmNlcy5cclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZXRJbmRleGVzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleFtdPn0gUHJvbWlzZSByZXR1cm5pbmcgYXJyYXkgb2YgcmF3IGluZGV4IGluZm9ybWF0aW9uXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0SW5kZXhlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZSwgaW5kZXhlcztcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRSYXdJbmRleGVzKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXMgPSByZXNwb25zZS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBuZXcgSW5kZXgoX3RoaXMuY29uZmlnLCBpbmRleC51aWQsIGluZGV4LnByaW1hcnlLZXkpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGluZGV4ZXNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgdGhlIGluZGV4ZXMgaW4gdGhlaXIgcmF3IHZhbHVlIChubyBJbmRleCBpbnN0YW5jZXMpLlxyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGdldFJhd0luZGV4ZXNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEluZGV4UmVzcG9uc2VbXT59IFByb21pc2UgcmV0dXJuaW5nIGFycmF5IG9mIHJhdyBpbmRleCBpbmZvcm1hdGlvblxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmdldFJhd0luZGV4ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXNcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5kZXhcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVJbmRleFxyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIGluZGV4IFVJRFxyXG4gICAgICogQHBhcmFtIHtJbmRleE9wdGlvbnN9IG9wdGlvbnMgSW5kZXggb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW5kZXg8VD4+fSBQcm9taXNlIHJldHVybmluZyBJbmRleCBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmNyZWF0ZUluZGV4ID0gZnVuY3Rpb24gKHVpZCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBJbmRleC5jcmVhdGUodWlkLCBvcHRpb25zLCB0aGlzLmNvbmZpZyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGFuIGluZGV4XHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgdXBkYXRlSW5kZXhcclxuICAgICAqIEB0ZW1wbGF0ZSBUXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSBpbmRleCBVSURcclxuICAgICAqIEBwYXJhbSB7SW5kZXhPcHRpb25zfSBvcHRpb25zIEluZGV4IG9wdGlvbnMgdG8gdXBkYXRlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleDxUPj59IFByb21pc2UgcmV0dXJuaW5nIEluZGV4IGluc3RhbmNlIGFmdGVyIHVwZGF0aW5nXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUudXBkYXRlSW5kZXggPSBmdW5jdGlvbiAodWlkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5ldyBJbmRleCh0aGlzLmNvbmZpZywgdWlkKS51cGRhdGUob3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIGFuIGluZGV4XHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgZGVsZXRlSW5kZXhcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIGluZGV4IFVJRFxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBpbmRleCBpcyBkZWxldGVkIHN1Y2Nlc3NmdWxseVxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmRlbGV0ZUluZGV4ID0gZnVuY3Rpb24gKHVpZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3IEluZGV4KHRoaXMuY29uZmlnLCB1aWQpW1wiZGVsZXRlXCJdKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBhbiBpbmRleCBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBkZWxldGVJbmRleElmRXhpc3RzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSBpbmRleCBVSURcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRydWUgd2hlbiBpbmRleCBleGlzdHMgYW5kIGlzIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBvdGhlcndpc2UgZmFsc2UgaWYgaXQgZG9lcyBub3QgZXhpc3RcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5kZWxldGVJbmRleElmRXhpc3RzID0gZnVuY3Rpb24gKHVpZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVfMTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZWxldGVJbmRleCh1aWQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRydWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xLmNvZGUgPT09IFwiaW5kZXhfbm90X2ZvdW5kXCIgLyogSU5ERVhfTk9UX0ZPVU5EICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gVEFTS1NcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgYWxsIGNsaWVudCB0YXNrc1xyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGdldFRhc2tzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ8VGFza1tdPj59IC0gUHJvbWlzZSByZXR1cm5pbmcgYWxsIHRhc2tzXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0VGFza3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmdldENsaWVudFRhc2tzKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9uZSB0YXNrIG9uIHRoZSBjbGllbnQgc2NvcGVcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZXRUYXNrXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFza0lkIC0gVGFzayBpZGVudGlmaWVyXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUYXNrPn0gLSBQcm9taXNlIHJldHVybmluZyBhIHRhc2tcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRUYXNrID0gZnVuY3Rpb24gKHRhc2tJZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy50YXNrcy5nZXRDbGllbnRUYXNrKHRhc2tJZCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FpdCBmb3IgYSBiYXRjaCBvZiB0YXNrcyB0byBiZSBwcm9jZXNzZWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2Qgd2FpdEZvclRhc2tzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0YXNrSWRzIC0gVGFza3MgaWRlbnRpZmllclxyXG4gICAgICogQHBhcmFtIHtXYWl0T3B0aW9uc30gd2FpdE9wdGlvbnMgLSBPcHRpb25zIG9uIHRpbWVvdXQgYW5kIGludGVydmFsXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0PFRhc2tbXT4+fSAtIFByb21pc2UgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRhc2tzXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUud2FpdEZvclRhc2tzID0gZnVuY3Rpb24gKHRhc2tJZHMsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IudGltZU91dE1zLCB0aW1lT3V0TXMgPSBfYyA9PT0gdm9pZCAwID8gNTAwMCA6IF9jLCBfZCA9IF9iLmludGVydmFsTXMsIGludGVydmFsTXMgPSBfZCA9PT0gdm9pZCAwID8gNTAgOiBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudGFza3Mud2FpdEZvckNsaWVudFRhc2tzKHRhc2tJZHMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPdXRNczogdGltZU91dE1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxNc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Uuc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0IGZvciBhIHRhc2sgdG8gYmUgcHJvY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCB3YWl0Rm9yVGFza1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhc2tJZCAtIFRhc2sgaWRlbnRpZmllclxyXG4gICAgICogQHBhcmFtIHtXYWl0T3B0aW9uc30gd2FpdE9wdGlvbnMgLSBPcHRpb25zIG9uIHRpbWVvdXQgYW5kIGludGVydmFsXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VGFzaz59IC0gUHJvbWlzZSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGFza3NcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS53YWl0Rm9yVGFzayA9IGZ1bmN0aW9uICh0YXNrSWQsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IudGltZU91dE1zLCB0aW1lT3V0TXMgPSBfYyA9PT0gdm9pZCAwID8gNTAwMCA6IF9jLCBfZCA9IF9iLmludGVydmFsTXMsIGludGVydmFsTXMgPSBfZCA9PT0gdm9pZCAwID8gNTAgOiBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudGFza3Mud2FpdEZvckNsaWVudFRhc2sodGFza0lkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lT3V0TXM6IHRpbWVPdXRNcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsTXM6IGludGVydmFsTXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9lLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIEtFWVNcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIEFQSSBrZXlzXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgZ2V0S2V5c1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8S2V5cz59IFByb21pc2UgcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGtleXNcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRLZXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJrZXlzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9uZSBBUEkga2V5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgZ2V0S2V5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIEtleVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8S2V5cz59IFByb21pc2UgcmV0dXJuaW5nIGEga2V5XHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJrZXlzL1wiLmNvbmNhdChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBvbmUgQVBJIGtleVxyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUtleVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7S2V5UGF5bG9hZH0gb3B0aW9ucyAtIEtleSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXk+fSBQcm9taXNlIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBrZXlzXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuY3JlYXRlS2V5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwia2V5c1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBvcHRpb25zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgb25lIEFQSSBrZXlcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVLZXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gS2V5XHJcbiAgICAgKiBAcGFyYW0ge0tleVBheWxvYWR9IG9wdGlvbnMgLSBLZXkgb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8S2V5Pn0gUHJvbWlzZSByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGgga2V5c1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLnVwZGF0ZUtleSA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwia2V5cy9cIi5jb25jYXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wYXRjaCh1cmwsIG9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBvbmUgQVBJIGtleVxyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGRlbGV0ZUtleVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBLZXlcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFZvaWQ+fVxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmRlbGV0ZUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwia2V5cy9cIi5jb25jYXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBIRUFMVEhcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIHNlcnZlciBpcyBoZWFsdGh5LCBvdGhlcndpc2UgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgaGVhbHRoXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIZWFsdGg+fSBQcm9taXNlIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBoZWFsdGggZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmhlYWx0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaGVhbHRoXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBzZXJ2ZXIgaXMgaGVhbHRoeSwgcmV0dXJuIHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgaXNIZWFsdGh5XHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gUHJvbWlzZSByZXR1cm5pbmcgYSBib29sZWFuXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuaXNIZWFsdGh5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJoZWFsdGhcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cnVlXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU1RBVFNcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHN0YXRzIG9mIGFsbCB0aGUgZGF0YWJhc2VcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZXRTdGF0c1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U3RhdHM+fSBQcm9taXNlIHJldHVybmluZyBvYmplY3Qgb2YgYWxsIHRoZSBzdGF0c1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJzdGF0c1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBWRVJTSU9OXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2ZXJzaW9uIG9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgZ2V0VmVyc2lvblxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VmVyc2lvbj59IFByb21pc2UgcmV0dXJuaW5nIG9iamVjdCB3aXRoIHZlcnNpb24gZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmdldFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcInZlcnNpb25cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gRFVNUFNcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyBhIGR1bXAgY3JlYXRpb24gcHJvY2Vzc1xyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUR1bXBcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkRHVtcD59IFByb21pc2UgcmV0dXJuaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuY3JlYXRlRHVtcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiZHVtcHNcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSBkdW1wIGNyZWF0aW9uIHByb2Nlc3NcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZXREdW1wU3RhdHVzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZHVtcFVpZCBEdW1wIFVJRFxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWREdW1wPn0gUHJvbWlzZSByZXR1cm5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXREdW1wU3RhdHVzID0gZnVuY3Rpb24gKGR1bXBVaWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiZHVtcHMvXCIuY29uY2F0KGR1bXBVaWQsIFwiL3N0YXR1c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBhIHRlbmFudCB0b2tlblxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZW5lcmF0ZVRlbmFudFRva2VuXHJcbiAgICAgKiBAcGFyYW0ge1NlYXJjaFJ1bGVzfSBzZWFyY2hSdWxlcyBTZWFyY2ggcnVsZXMgdGhhdCBhcmUgYXBwbGllZCB0byBldmVyeSBzZWFyY2guXHJcbiAgICAgKiBAcGFyYW0ge1Rva2VuT3B0aW9uc30gb3B0aW9ucyBUb2tlbiBvcHRpb25zIHRvIGN1c3RvbWl6ZSBzb21lIGFzcGVjdCBvZiB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdG9rZW4gaW4gSldUIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZW5lcmF0ZVRlbmFudFRva2VuID0gZnVuY3Rpb24gKF9zZWFyY2hSdWxlcywgX29wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZWlsaXNlYXJjaDogZmFpbGVkIHRvIGdlbmVyYXRlIGEgdGVuYW50IHRva2VuLiBHZW5lcmF0aW9uIG9mIGEgdG9rZW4gb25seSB3b3JrcyBpbiBhIG5vZGUgZW52aXJvbm1lbnQgXFxuIFwiLmNvbmNhdChlcnJvci5zdGFjaywgXCIuXCIpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2xpZW50O1xyXG59KCkpO1xuXG5mdW5jdGlvbiBlbmNvZGU2NChkYXRhKSB7XHJcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoZGF0YSkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIHRoZSBoZWFkZXIgb2YgdGhlIHRva2VuLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYXBpS2V5IEFQSSBrZXkgdXNlZCB0byBzaWduIHRoZSB0b2tlbi5cclxuICogQHBhcmFtIHtTdHJpbmd9IGVuY29kZWRIZWFkZXIgSGVhZGVyIG9mIHRoZSB0b2tlbiBpbiBiYXNlNjQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGVkUGF5bG9hZCBQYXlsb2FkIG9mIHRoZSB0b2tlbiBpbiBiYXNlNjQuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzaWduYXR1cmUgb2YgdGhlIHRva2VuIGluIGJhc2U2NC5cclxuICovXHJcbmZ1bmN0aW9uIHNpZ24oYXBpS2V5LCBlbmNvZGVkSGVhZGVyLCBlbmNvZGVkUGF5bG9hZCkge1xyXG4gICAgcmV0dXJuIGNyeXB0b19fZGVmYXVsdFtcImRlZmF1bHRcIl1cclxuICAgICAgICAuY3JlYXRlSG1hYygnc2hhMjU2JywgYXBpS2V5KVxyXG4gICAgICAgIC51cGRhdGUoXCJcIi5jb25jYXQoZW5jb2RlZEhlYWRlciwgXCIuXCIpLmNvbmNhdChlbmNvZGVkUGF5bG9hZCkpXHJcbiAgICAgICAgLmRpZ2VzdCgnYmFzZTY0JylcclxuICAgICAgICAucmVwbGFjZSgvXFwrL2csICctJylcclxuICAgICAgICAucmVwbGFjZSgvXFwvL2csICdfJylcclxuICAgICAgICAucmVwbGFjZSgvPS9nLCAnJyk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSB0aGUgaGVhZGVyIG9mIHRoZSB0b2tlbi5cclxuICpcclxuICogQHJldHVybnMge1N0cmluZ30gVGhlIGhlYWRlciBlbmNvZGVkIGluIGJhc2U2NC5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcigpIHtcclxuICAgIHZhciBoZWFkZXIgPSB7XHJcbiAgICAgICAgYWxnOiAnSFMyNTYnLFxyXG4gICAgICAgIHR5cDogJ0pXVCdcclxuICAgIH07XHJcbiAgICByZXR1cm4gZW5jb2RlNjQoaGVhZGVyKS5yZXBsYWNlKC89L2csICcnKTtcclxufVxyXG4vKipcclxuICogVmFsaWRhdGUgdGhlIHBhcmFtZXRlciB1c2VkIGZvciB0aGUgcGF5bG9hZCBvZiB0aGUgdG9rZW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U2VhcmNoUnVsZXN9IHNlYXJjaFJ1bGVzIFNlYXJjaCBydWxlcyB0aGF0IGFyZSBhcHBsaWVkIHRvIGV2ZXJ5IHNlYXJjaC5cclxuICogQHBhcmFtIHtTdHJpbmd9IGFwaUtleSBBcGkga2V5IHVzZWQgYXMgaXNzdWVyIG9mIHRoZSB0b2tlbi5cclxuICogQHBhcmFtIHtEYXRlIHwgdW5kZWZpbmVkfSBleHBpcmVzQXQgRGF0ZSBhdCB3aGljaCB0aGUgdG9rZW4gZXhwaXJlcy5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUGF5bG9hZChwYXlsb2FkUGFyYW1zKSB7XHJcbiAgICB2YXIgc2VhcmNoUnVsZXMgPSBwYXlsb2FkUGFyYW1zLnNlYXJjaFJ1bGVzLCBhcGlLZXkgPSBwYXlsb2FkUGFyYW1zLmFwaUtleSwgZXhwaXJlc0F0ID0gcGF5bG9hZFBhcmFtcy5leHBpcmVzQXQ7XHJcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcclxuICAgIGlmIChleHBpcmVzQXQpIHtcclxuICAgICAgICBpZiAoIShleHBpcmVzQXQgaW5zdGFuY2VvZiBEYXRlKSB8fCBleHBpcmVzQXQuZ2V0VGltZSgpIDwgRGF0ZS5ub3coKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZWlsaXNlYXJjaDogV2hlbiB0aGUgZXhwaXJlc0F0IGZpZWxkIGluIHRoZSB0b2tlbiBnZW5lcmF0aW9uIGhhcyBhIHZhbHVlLCBpdCBtdXN0IGJlIGEgZGF0ZSBzZXQgaW4gdGhlIGZ1dHVyZSBhbmQgbm90IGluIHRoZSBwYXN0LiBcXG4gXCIuY29uY2F0KGVycm9yLnN0YWNrLCBcIi5cIikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzZWFyY2hSdWxlcykge1xyXG4gICAgICAgIGlmICghKHR5cGVvZiBzZWFyY2hSdWxlcyA9PT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShzZWFyY2hSdWxlcykpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1laWxpc2VhcmNoOiBUaGUgc2VhcmNoIHJ1bGVzIGFkZGVkIGluIHRoZSB0b2tlbiBnZW5lcmF0aW9uIG11c3QgYmUgb2YgdHlwZSBhcnJheSBvciBvYmplY3QuIFxcbiBcIi5jb25jYXQoZXJyb3Iuc3RhY2ssIFwiLlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFhcGlLZXkgfHwgdHlwZW9mIGFwaUtleSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZWlsaXNlYXJjaDogVGhlIEFQSSBrZXkgdXNlZCBmb3IgdGhlIHRva2VuIGdlbmVyYXRpb24gbXVzdCBleGlzdCBhbmQgYmUgb2YgdHlwZSBzdHJpbmcuIFxcbiBcIi5jb25jYXQoZXJyb3Iuc3RhY2ssIFwiLlwiKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSB0aGUgcGF5bG9hZCBvZiB0aGUgdG9rZW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U2VhcmNoUnVsZXN9IHNlYXJjaFJ1bGVzIFNlYXJjaCBydWxlcyB0aGF0IGFyZSBhcHBsaWVkIHRvIGV2ZXJ5IHNlYXJjaC5cclxuICogQHBhcmFtIHtTdHJpbmd9IGFwaUtleSBBcGkga2V5IHVzZWQgYXMgaXNzdWVyIG9mIHRoZSB0b2tlbi5cclxuICogQHBhcmFtIHtEYXRlIHwgdW5kZWZpbmVkfSBleHBpcmVzQXQgRGF0ZSBhdCB3aGljaCB0aGUgdG9rZW4gZXhwaXJlcy5cclxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHBheWxvYWQgZW5jb2RlZCBpbiBiYXNlNjQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVQYXlsb2FkKHBheWxvYWRQYXJhbXMpIHtcclxuICAgIHZhciBzZWFyY2hSdWxlcyA9IHBheWxvYWRQYXJhbXMuc2VhcmNoUnVsZXMsIGFwaUtleSA9IHBheWxvYWRQYXJhbXMuYXBpS2V5LCBleHBpcmVzQXQgPSBwYXlsb2FkUGFyYW1zLmV4cGlyZXNBdDtcclxuICAgIHZhbGlkYXRlUGF5bG9hZChwYXlsb2FkUGFyYW1zKTtcclxuICAgIHZhciBwYXlsb2FkID0ge1xyXG4gICAgICAgIHNlYXJjaFJ1bGVzOiBzZWFyY2hSdWxlcyxcclxuICAgICAgICBhcGlLZXlQcmVmaXg6IGFwaUtleS5zdWJzdHJpbmcoMCwgOCksXHJcbiAgICAgICAgZXhwOiBleHBpcmVzQXQgPT09IG51bGwgfHwgZXhwaXJlc0F0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHBpcmVzQXQuZ2V0VGltZSgpXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGVuY29kZTY0KHBheWxvYWQpLnJlcGxhY2UoLz0vZywgJycpO1xyXG59XHJcbnZhciBUb2tlbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRva2VuKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBhIHRlbmFudCB0b2tlblxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZW5lcmF0ZVRlbmFudFRva2VuXHJcbiAgICAgKiBAcGFyYW0ge1NlYXJjaFJ1bGVzfSBzZWFyY2hSdWxlcyBTZWFyY2ggcnVsZXMgdGhhdCBhcmUgYXBwbGllZCB0byBldmVyeSBzZWFyY2guXHJcbiAgICAgKiBAcGFyYW0ge1Rva2VuT3B0aW9uc30gb3B0aW9ucyBUb2tlbiBvcHRpb25zIHRvIGN1c3RvbWl6ZSBzb21lIGFzcGVjdCBvZiB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdG9rZW4gaW4gSldUIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgVG9rZW4ucHJvdG90eXBlLmdlbmVyYXRlVGVuYW50VG9rZW4gPSBmdW5jdGlvbiAoc2VhcmNoUnVsZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgYXBpS2V5ID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hcGlLZXkpIHx8IHRoaXMuY29uZmlnLmFwaUtleSB8fCAnJztcclxuICAgICAgICB2YXIgZXhwaXJlc0F0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV4cGlyZXNBdDtcclxuICAgICAgICB2YXIgZW5jb2RlZEhlYWRlciA9IGNyZWF0ZUhlYWRlcigpO1xyXG4gICAgICAgIHZhciBlbmNvZGVkUGF5bG9hZCA9IGNyZWF0ZVBheWxvYWQoeyBzZWFyY2hSdWxlczogc2VhcmNoUnVsZXMsIGFwaUtleTogYXBpS2V5LCBleHBpcmVzQXQ6IGV4cGlyZXNBdCB9KTtcclxuICAgICAgICB2YXIgc2lnbmF0dXJlID0gc2lnbihhcGlLZXksIGVuY29kZWRIZWFkZXIsIGVuY29kZWRQYXlsb2FkKTtcclxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZW5jb2RlZEhlYWRlciwgXCIuXCIpLmNvbmNhdChlbmNvZGVkUGF5bG9hZCwgXCIuXCIpLmNvbmNhdChzaWduYXR1cmUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUb2tlbjtcclxufSgpKTtcblxudmFyIE1laWxpU2VhcmNoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1laWxpU2VhcmNoLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWVpbGlTZWFyY2goY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29uZmlnKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnRva2VucyA9IG5ldyBUb2tlbihjb25maWcpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgYSB0ZW5hbnQgdG9rZW5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgZ2VuZXJhdGVUZW5hbnRUb2tlblxyXG4gICAgICogQHBhcmFtIHtTZWFyY2hSdWxlc30gc2VhcmNoUnVsZXMgU2VhcmNoIHJ1bGVzIHRoYXQgYXJlIGFwcGxpZWQgdG8gZXZlcnkgc2VhcmNoLlxyXG4gICAgICogQHBhcmFtIHtUb2tlbk9wdGlvbnN9IG9wdGlvbnMgVG9rZW4gb3B0aW9ucyB0byBjdXN0b21pemUgc29tZSBhc3BlY3Qgb2YgdGhlIHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHRva2VuIGluIEpXVCBmb3JtYXQuXHJcbiAgICAgKi9cclxuICAgIE1laWxpU2VhcmNoLnByb3RvdHlwZS5nZW5lcmF0ZVRlbmFudFRva2VuID0gZnVuY3Rpb24gKHNlYXJjaFJ1bGVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5nZW5lcmF0ZVRlbmFudFRva2VuKHNlYXJjaFJ1bGVzLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2VuZXJhdGVUZW5hbnRUb2tlbi5jYWxsKHRoaXMsIHNlYXJjaFJ1bGVzLCBvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTWVpbGlTZWFyY2g7XHJcbn0oQ2xpZW50KSk7XG5cbmV4cG9ydHMuSHR0cFJlcXVlc3RzID0gSHR0cFJlcXVlc3RzO1xuZXhwb3J0cy5JbmRleCA9IEluZGV4O1xuZXhwb3J0cy5NZWlsaVNlYXJjaCA9IE1laWxpU2VhcmNoO1xuZXhwb3J0cy5NZWlsaVNlYXJjaEFwaUVycm9yID0gTWVpbGlTZWFyY2hBcGlFcnJvcjtcbmV4cG9ydHMuTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3IgPSBNZWlsaVNlYXJjaENvbW11bmljYXRpb25FcnJvcjtcbmV4cG9ydHMuTWVpbGlTZWFyY2hFcnJvciA9IE1laWxpU2VhcmNoRXJyb3I7XG5leHBvcnRzLk1laWxpU2VhcmNoVGltZU91dEVycm9yID0gTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3I7XG5leHBvcnRzLmFkZFByb3RvY29sSWZOb3RQcmVzZW50ID0gYWRkUHJvdG9jb2xJZk5vdFByZXNlbnQ7XG5leHBvcnRzLmFkZFRyYWlsaW5nU2xhc2ggPSBhZGRUcmFpbGluZ1NsYXNoO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBNZWlsaVNlYXJjaDtcbmV4cG9ydHMuaHR0cEVycm9ySGFuZGxlciA9IGh0dHBFcnJvckhhbmRsZXI7XG5leHBvcnRzLmh0dHBSZXNwb25zZUVycm9ySGFuZGxlciA9IGh0dHBSZXNwb25zZUVycm9ySGFuZGxlcjtcbmV4cG9ydHMucmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdCA9IHJlbW92ZVVuZGVmaW5lZEZyb21PYmplY3Q7XG5leHBvcnRzLnNsZWVwID0gc2xlZXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/meilisearch/dist/bundles/meilisearch.cjs.js\n");

/***/ })

};
;