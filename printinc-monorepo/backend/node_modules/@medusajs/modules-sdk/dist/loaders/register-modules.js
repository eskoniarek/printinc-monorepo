"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerMedusaLinkModule = exports.registerMedusaModule = exports.registerModules = void 0;
const types_1 = require("@medusajs/types");
const utils_1 = require("@medusajs/utils");
const resolve_cwd_1 = __importDefault(require("resolve-cwd"));
const definitions_1 = require("../definitions");
/**
 *
 * @param modules
 * @param isolatedModules Will be removed once the isolated flag is being removed
 */
// TODO: Remove once we have all modules migrated + rename to something like getResolutions
const registerModules = (modules, { loadLegacyOnly } = { loadLegacyOnly: false }) => {
    const moduleResolutions = {};
    const projectModules = modules ?? {};
    for (const definition of definitions_1.MODULE_DEFINITIONS) {
        // Skip non legacy modules
        if (loadLegacyOnly && !definition.isLegacy) {
            continue;
        }
        const customConfig = projectModules[definition.key];
        const canSkip = !customConfig && !definition.isRequired && !definition.defaultPackage;
        const isObj = (0, utils_1.isObject)(customConfig);
        if (isObj && customConfig.scope === types_1.MODULE_SCOPE.EXTERNAL) {
            // TODO: getExternalModuleResolution(...)
            if (!canSkip) {
                throw new Error("External Modules are not supported yet.");
            }
        }
        moduleResolutions[definition.key] = getInternalModuleResolution(definition, customConfig);
    }
    return moduleResolutions;
};
exports.registerModules = registerModules;
const registerMedusaModule = (moduleKey, moduleDeclaration, moduleExports, definition) => {
    const moduleResolutions = {};
    const modDefinition = definition ?? definitions_1.ModulesDefinition[moduleKey];
    if (modDefinition === undefined) {
        throw new Error(`Module: ${moduleKey} is not defined.`);
    }
    if ((0, utils_1.isObject)(moduleDeclaration) &&
        moduleDeclaration?.scope === types_1.MODULE_SCOPE.EXTERNAL) {
        // TODO: getExternalModuleResolution(...)
        throw new Error("External Modules are not supported yet.");
    }
    moduleResolutions[moduleKey] = getInternalModuleResolution(modDefinition, moduleDeclaration, moduleExports);
    return moduleResolutions;
};
exports.registerMedusaModule = registerMedusaModule;
const registerMedusaLinkModule = (definition, moduleDeclaration, moduleExports) => {
    const moduleResolutions = {};
    moduleResolutions[definition.key] = getInternalModuleResolution(definition, moduleDeclaration, moduleExports);
    return moduleResolutions;
};
exports.registerMedusaLinkModule = registerMedusaLinkModule;
function getInternalModuleResolution(definition, moduleConfig, moduleExports) {
    if (typeof moduleConfig === "boolean") {
        if (!moduleConfig && definition.isRequired) {
            throw new Error(`Module: ${definition.label} is required`);
        }
        if (!moduleConfig) {
            return {
                resolutionPath: false,
                definition,
                dependencies: [],
                options: {},
            };
        }
    }
    const isObj = typeof moduleConfig === "object";
    let resolutionPath = definition.defaultPackage;
    // If user added a module and it's overridable, we resolve that instead
    const isString = typeof moduleConfig === "string";
    if (definition.canOverride && (isString || (isObj && moduleConfig.resolve))) {
        resolutionPath = !moduleExports
            ? (0, resolve_cwd_1.default)(isString ? moduleConfig : moduleConfig.resolve)
            : // Explicitly assign an empty string, later, we will check if the value is exactly false.
                // This allows to continue the module loading while using the module exports instead of re importing the module itself during the process.
                "";
    }
    const moduleDeclaration = isObj ? moduleConfig : {};
    const additionalDependencies = isObj ? moduleConfig.dependencies || [] : [];
    return {
        resolutionPath,
        definition,
        dependencies: [
            ...new Set((definition.dependencies || []).concat(additionalDependencies)),
        ],
        moduleDeclaration: {
            ...(definition.defaultModuleDeclaration ?? {}),
            ...moduleDeclaration,
        },
        moduleExports,
        options: isObj ? moduleConfig.options ?? {} : {},
    };
}
//# sourceMappingURL=register-modules.js.map